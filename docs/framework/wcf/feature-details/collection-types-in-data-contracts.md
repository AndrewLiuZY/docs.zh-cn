---
title: 数据协定中的集合类型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579744"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="26d73-102">数据协定中的集合类型</span><span class="sxs-lookup"><span data-stu-id="26d73-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="26d73-103">\*\* “集合”指特定类型的项的列表。</span><span class="sxs-lookup"><span data-stu-id="26d73-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="26d73-104">在 .NET Framework 中，可以使用数组或其他各种类型（泛型列表、泛型 <xref:System.ComponentModel.BindingList%601> 、或）来表示此类列表 <xref:System.Collections.Specialized.StringCollection> <xref:System.Collections.ArrayList> 。</span><span class="sxs-lookup"><span data-stu-id="26d73-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="26d73-105">例如，集合可以容纳给定客户的地址列表。</span><span class="sxs-lookup"><span data-stu-id="26d73-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="26d73-106">无论这些集合的实际类型是什么，这些集合都称为“列表集合” \*\*。</span><span class="sxs-lookup"><span data-stu-id="26d73-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="26d73-107">存在一种特殊形式的集合，该集合表示某一项（“键”）与另一项（“值”）之间的关联。</span><span class="sxs-lookup"><span data-stu-id="26d73-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="26d73-108">在 .NET Framework 中，它们由类型（如） <xref:System.Collections.Hashtable> 和泛型字典来表示。</span><span class="sxs-lookup"><span data-stu-id="26d73-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="26d73-109">例如，一个关联集合可能将城市（“键”）映射到它的人口数量（“值”）。</span><span class="sxs-lookup"><span data-stu-id="26d73-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="26d73-110">无论这些集合的实际类型是什么，这些集合都称为“字典集合” \*\*。</span><span class="sxs-lookup"><span data-stu-id="26d73-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="26d73-111">集合在数据协定模型中受到特殊对待。</span><span class="sxs-lookup"><span data-stu-id="26d73-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="26d73-112">实现 <xref:System.Collections.IEnumerable> 接口的类型（包括数组和泛型集合）被识别为集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="26d73-113">其中，实现 <xref:System.Collections.IDictionary> 或泛型 <xref:System.Collections.Generic.IDictionary%602> 接口的类型是字典集合，其他所有类型是列表集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="26d73-114">以下各节将详细讨论集合类型的其他要求（例如，具有一个名为的方法 `Add` 和一个无参数的构造函数）。</span><span class="sxs-lookup"><span data-stu-id="26d73-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="26d73-115">这确保了既可以对集合类型序列化，也可以对其反序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="26d73-116">这意味着不直接支持某些集合，例如泛型 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> （因为它没有无参数的构造函数）。</span><span class="sxs-lookup"><span data-stu-id="26d73-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="26d73-117">但是，也可以避开这些限制。有关信息，请参见本主题后面的“使用集合接口类型和只读集合”。</span><span class="sxs-lookup"><span data-stu-id="26d73-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="26d73-118">包含在集合中的类型必须是数据协定类型，或者是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="26d73-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="26d73-119">有关详细信息，请参阅[数据协定序列化程序支持的类型](types-supported-by-the-data-contract-serializer.md)。</span><span class="sxs-lookup"><span data-stu-id="26d73-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="26d73-120">有关什么是以及哪些内容不被视为有效集合，以及如何序列化集合的详细信息，请参阅本主题的 "高级集合规则" 部分中有关序列化集合的信息。</span><span class="sxs-lookup"><span data-stu-id="26d73-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="26d73-121">可互换的集合</span><span class="sxs-lookup"><span data-stu-id="26d73-121">Interchangeable Collections</span></span>

<span data-ttu-id="26d73-122">同一类型的所有列表集合均被视为具有相同的数据协定（除非它们是使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性自定义的，如本主题后面所述）。</span><span class="sxs-lookup"><span data-stu-id="26d73-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="26d73-123">因此，举例而言，下面的数据协定是等效的。</span><span class="sxs-lookup"><span data-stu-id="26d73-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="26d73-124">两个数据协定均产生类似于以下代码的 XML。</span><span class="sxs-lookup"><span data-stu-id="26d73-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="26d73-125">举例而言，集合的可互换性使您可以使用一个针对服务器性能而优化的集合类型，以及一个旨在绑定到客户端上的用户界面组件的集合类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="26d73-126">与列表集合类似，具有相同键和值类型的所有字典集合都被视为具有相同的数据协定（除非通过 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性自定义）。</span><span class="sxs-lookup"><span data-stu-id="26d73-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="26d73-127">就集合等效性而言，只有数据协定类型才有意义，.NET 类型并无意义。</span><span class="sxs-lookup"><span data-stu-id="26d73-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="26d73-128">也就是说，如果 Type1 和 Type2 具有等效的数据协定，那么 Type1 的集合将被视为与 Type2 的集合等效。</span><span class="sxs-lookup"><span data-stu-id="26d73-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="26d73-129">非泛型集合被视为与 `Object`类型的泛型集合具有相同的数据协定。</span><span class="sxs-lookup"><span data-stu-id="26d73-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="26d73-130">（例如， <xref:System.Collections.ArrayList> 的数据协定与 <xref:System.Collections.Generic.List%601> 的泛型 `Object` 是相同的。）</span><span class="sxs-lookup"><span data-stu-id="26d73-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="26d73-131">使用集合接口类型和只读集合</span><span class="sxs-lookup"><span data-stu-id="26d73-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="26d73-132">集合接口类型（<xref:System.Collections.IEnumerable>、 <xref:System.Collections.IDictionary>、泛型 <xref:System.Collections.Generic.IDictionary%602>或从这些接口派生的接口）也被视为具有与实际集合类型的集合数据协定等效的集合数据协定。</span><span class="sxs-lookup"><span data-stu-id="26d73-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="26d73-133">因此，可以声明被序列化为集合接口类型的类型，并且结果与使用实际集合类型时的结果相同。</span><span class="sxs-lookup"><span data-stu-id="26d73-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="26d73-134">例如，下面的数据协定是等效的。</span><span class="sxs-lookup"><span data-stu-id="26d73-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="26d73-135">序列化期间，当声明的类型是接口时，使用的实际实例类型可以是实现该接口的任何类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="26d73-136">前面讨论的限制（具有无参数的构造函数和 `Add` 方法）不适用。</span><span class="sxs-lookup"><span data-stu-id="26d73-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="26d73-137">例如，即使您不能直接声明泛型 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 类型的数据成员，仍然可以将 Customer2 中的地址设置为 Address 的泛型 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>的实例。</span><span class="sxs-lookup"><span data-stu-id="26d73-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="26d73-138">反序列化期间，当声明的类型是接口时，序列化引擎会选择实现所声明的接口的类型，并且该类型会实例化。</span><span class="sxs-lookup"><span data-stu-id="26d73-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="26d73-139">已知的类型机制（在[数据协定已知类型](data-contract-known-types.md)中介绍）在这里没有任何效果;类型的选择内置于 WCF 中。</span><span class="sxs-lookup"><span data-stu-id="26d73-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="26d73-140">自定义集合类型</span><span class="sxs-lookup"><span data-stu-id="26d73-140">Customizing Collection Types</span></span>

<span data-ttu-id="26d73-141">您可以通过使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性来自定义集合类型，该属性具有几种用法。</span><span class="sxs-lookup"><span data-stu-id="26d73-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="26d73-142">请注意，自定义集合类型会危害集合的可互换性，因此通常建议尽量避免应用此特性。</span><span class="sxs-lookup"><span data-stu-id="26d73-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="26d73-143">有关此问题的详细信息，请参阅本主题后面的 "高级集合规则" 一节。</span><span class="sxs-lookup"><span data-stu-id="26d73-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="26d73-144">集合数据协定命名</span><span class="sxs-lookup"><span data-stu-id="26d73-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="26d73-145">如 [Data Contract Names](data-contract-names.md)中所述，命名集合类型的规则与命名常规数据协定类型的规则类似，但存在一些重要的区别：</span><span class="sxs-lookup"><span data-stu-id="26d73-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="26d73-146">使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性（而不是 <xref:System.Runtime.Serialization.DataContractAttribute> 属性）来自定义名称。</span><span class="sxs-lookup"><span data-stu-id="26d73-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="26d73-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性 (Attribute) 也有 `Name` 和 `Namespace` 属性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="26d73-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="26d73-148">当未应用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性时，集合类型的默认名称和命名空间依赖于集合内包含的类型的名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="26d73-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="26d73-149">它们不受集合类型本身的名称和命名空间的影响。</span><span class="sxs-lookup"><span data-stu-id="26d73-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="26d73-150">有关示例，请参见以下类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="26d73-151">两个类型的数据协定名称都是“ArrayOfstring”，而不是“CustomerList1”或“StringList1”。</span><span class="sxs-lookup"><span data-stu-id="26d73-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="26d73-152">这意味着在根级别序列化其中任何一个类型都将产生与下面的代码类似的 XML。</span><span class="sxs-lookup"><span data-stu-id="26d73-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="26d73-153">选择此命名规则可确保表示字符串列表的任何非自定义类型都具有相同的数据协定和 XML 表示。</span><span class="sxs-lookup"><span data-stu-id="26d73-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="26d73-154">这使得集合的可互换性成为可能。</span><span class="sxs-lookup"><span data-stu-id="26d73-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="26d73-155">在本例中，CustomerList1 和 StringList1 是完全可互换的。</span><span class="sxs-lookup"><span data-stu-id="26d73-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="26d73-156">但是，当应用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性时，集合将成为一个自定义的集合数据协定，即使未在该属性 (Attribute) 上设置任何属性 (Property) 也将如此。</span><span class="sxs-lookup"><span data-stu-id="26d73-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="26d73-157">之后，集合数据协定的名称和命名空间将取决于集合类型本身。</span><span class="sxs-lookup"><span data-stu-id="26d73-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="26d73-158">有关示例，请参见下面的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="26d73-159">序列化后，所产生的 XML 将类似于以下代码：</span><span class="sxs-lookup"><span data-stu-id="26d73-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="26d73-160">请注意，这不再等效于非自定义类型的 XML 表示。</span><span class="sxs-lookup"><span data-stu-id="26d73-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="26d73-161">您可以使用 `Name` 和 `Namespace` 属性来进一步自定义命名。</span><span class="sxs-lookup"><span data-stu-id="26d73-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="26d73-162">请参见下面的类。</span><span class="sxs-lookup"><span data-stu-id="26d73-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="26d73-163">所产生的 XML 类似于以下内容。</span><span class="sxs-lookup"><span data-stu-id="26d73-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="26d73-164">有关详细信息，请参阅本主题后面的 "高级集合规则" 一节。</span><span class="sxs-lookup"><span data-stu-id="26d73-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="26d73-165">自定义列表集合中的重复元素名称</span><span class="sxs-lookup"><span data-stu-id="26d73-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="26d73-166">列表集合包含重复项。</span><span class="sxs-lookup"><span data-stu-id="26d73-166">List collections contain repeating entries.</span></span> <span data-ttu-id="26d73-167">通常，每个重复项都表示为根据集合中包含的类型的数据协定名称而命名的元素。</span><span class="sxs-lookup"><span data-stu-id="26d73-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="26d73-168">在 `CustomerList` 示例中，集合包含字符串。</span><span class="sxs-lookup"><span data-stu-id="26d73-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="26d73-169">String 基元类型的数据协定名称为 "string"，因此重复元素为 " \<string> "。</span><span class="sxs-lookup"><span data-stu-id="26d73-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="26d73-170">但是，通过对 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 属性 (Attribute) 使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性 (Property)，可以自定义该重复元素名称。</span><span class="sxs-lookup"><span data-stu-id="26d73-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="26d73-171">有关示例，请参见下面的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="26d73-172">所产生的 XML 类似于以下内容。</span><span class="sxs-lookup"><span data-stu-id="26d73-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="26d73-173">重复元素的命名空间始终与集合数据协定的命名空间相同，如前所述，该命名空间可以使用 `Namespace` 属性自定义。</span><span class="sxs-lookup"><span data-stu-id="26d73-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="26d73-174">自定义字典集合</span><span class="sxs-lookup"><span data-stu-id="26d73-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="26d73-175">字典集合实质上是项列表，其中每一项都有一个后面跟随值的键。</span><span class="sxs-lookup"><span data-stu-id="26d73-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="26d73-176">与常规列表一样，您可以使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> 属性更改与重复元素对应的元素名称。</span><span class="sxs-lookup"><span data-stu-id="26d73-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="26d73-177">此外，您还可以使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 和 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 属性来更改表示键和值的元素名称。</span><span class="sxs-lookup"><span data-stu-id="26d73-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="26d73-178">这些元素的命名空间与集合数据协定的命名空间相同。</span><span class="sxs-lookup"><span data-stu-id="26d73-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="26d73-179">有关示例，请参见下面的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="26d73-180">序列化后，所产生的 XML 将类似于以下代码：</span><span class="sxs-lookup"><span data-stu-id="26d73-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="26d73-181">有关字典集合的详细信息，请参阅本主题后面的 "高级集合规则" 一节。</span><span class="sxs-lookup"><span data-stu-id="26d73-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="26d73-182">集合和已知类型</span><span class="sxs-lookup"><span data-stu-id="26d73-182">Collections and Known Types</span></span>

<span data-ttu-id="26d73-183">如果集合类型是以多态方式来代替其他集合或集合接口的，您不需要将这样的集合类型添加到已知类型中。</span><span class="sxs-lookup"><span data-stu-id="26d73-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="26d73-184">例如，如果您声明一个 <xref:System.Collections.IEnumerable> 类型的数据成员并将其用于发送 <xref:System.Collections.ArrayList>的一个实例，则无需将 <xref:System.Collections.ArrayList> 添加到已知类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="26d73-185">当您以多态方式使用集合来代替非集合类型时，必须将这些集合添加到已知类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="26d73-186">例如，如果您声明一个 `Object` 类型的数据成员并将其用于发送 <xref:System.Collections.ArrayList>的一个实例，则需要将 <xref:System.Collections.ArrayList> 添加到已知类型中。</span><span class="sxs-lookup"><span data-stu-id="26d73-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="26d73-187">这不允许您以多态方式序列化任何等效集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="26d73-188">例如，当您将 <xref:System.Collections.ArrayList> 添加到前面示例中的已知类型列表时，这不允许您指定 `Array of Object` 类，即使该类具有等效的数据协定也是如此。</span><span class="sxs-lookup"><span data-stu-id="26d73-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="26d73-189">这与常规的已知类型在非集合类型的序列化方面的行为没有任何不同，但对于集合而言了解这一点尤为重要，因为集合的等效性是很常见的。</span><span class="sxs-lookup"><span data-stu-id="26d73-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="26d73-190">在序列化期间，在给定数据协定的任何给定范围内，只能有一个类型是已知的，并且等效集合都有相同的数据协定。</span><span class="sxs-lookup"><span data-stu-id="26d73-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="26d73-191">这意味着，在前面的示例中，您不能将 <xref:System.Collections.ArrayList> 和 `Array of Object` 都添加到同一范围中的已知类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="26d73-192">同样，这与已知类型在非集合类型方面的行为是等效的，但对于集合而言，了解这一点尤为重要。</span><span class="sxs-lookup"><span data-stu-id="26d73-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="26d73-193">对于集合的内容而言，已知类型可能也是必需的。</span><span class="sxs-lookup"><span data-stu-id="26d73-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="26d73-194">例如，如果 <xref:System.Collections.ArrayList> 实际上包含 `Type1` 和 `Type2`的实例，则应将这两个类型都添加到已知类型中。</span><span class="sxs-lookup"><span data-stu-id="26d73-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="26d73-195">下面的示例演示使用集合和已知类型正确构造的对象图</span><span class="sxs-lookup"><span data-stu-id="26d73-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="26d73-196">本示例虚构成分稍浓，因为在实际的应用程序中，通常不会将下面的数据成员定义为 `Object`，因此不会有任何已知类型/多态性问题。</span><span class="sxs-lookup"><span data-stu-id="26d73-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="26d73-197">在反序列化时，如果声明的类型是集合类型，则无论实际发送的是什么类型，都会实例化所声明的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="26d73-198">如果所声明的类型是集合接口，则反序列化程序会选取一个要实例化的类型，而不会考虑该类型是否为已知类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="26d73-199">此外，在反序列化时，如果声明的类型不是一个集合类型，但要发送的是集合类型，则会在已知类型列表之中选取一个匹配的集合类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="26d73-200">可以在反序列化时将集合接口类型添加到已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="26d73-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="26d73-201">在这种情况下，反序列化引擎会再次选取要实例化的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="26d73-202">集合和 NetDataContractSerializer 类</span><span class="sxs-lookup"><span data-stu-id="26d73-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="26d73-203">当正在使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类时，非数组的非自定义集合类型（无 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性）会失去其特殊意义。</span><span class="sxs-lookup"><span data-stu-id="26d73-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="26d73-204">用 <xref:System.SerializableAttribute> 属性标记的非自定义集合类型仍然可以由 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类根据 <xref:System.SerializableAttribute> 属性或 <xref:System.Runtime.Serialization.ISerializable> 接口规则来序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="26d73-205">自定义的集合类型、集合接口以及数组仍然被视为集合，即使当正在使用 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类时也将如此。</span><span class="sxs-lookup"><span data-stu-id="26d73-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="26d73-206">集合与架构</span><span class="sxs-lookup"><span data-stu-id="26d73-206">Collections and Schema</span></span>

<span data-ttu-id="26d73-207">所有等效的集合在 XML 架构定义 (XSD) 语言架构中都具有相同的表示。</span><span class="sxs-lookup"><span data-stu-id="26d73-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="26d73-208">因此，您通常不会在所生成的客户端代码中获得与服务器上的集合类型相同的集合类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="26d73-209">例如，服务器可能使用具有 Integer 数据成员的泛型 <xref:System.Collections.Generic.List%601> 的数据协定，但是在生成的客户端代码中，该数据成员可能成为整数数组。</span><span class="sxs-lookup"><span data-stu-id="26d73-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="26d73-210">字典集合标记有特定于 WCF 的架构批注，该批注指示它们是字典;否则，它们不能与包含具有键和值的项的简单列表区分开来。</span><span class="sxs-lookup"><span data-stu-id="26d73-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="26d73-211">有关如何在数据协定架构中表示集合的准确说明，请参阅 [Data Contract Schema Reference](data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="26d73-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="26d73-212">默认情况下，不会为导入的代码中的非自定义集合生成类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="26d73-213">列表集合类型的数据成员是作为数组导入的，字典集合类型的数据成员是作为泛型字典导入的。</span><span class="sxs-lookup"><span data-stu-id="26d73-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="26d73-214">但是，对于自定义集合，将生成单独的类型，这样的类型会标记有 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性。</span><span class="sxs-lookup"><span data-stu-id="26d73-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="26d73-215">（架构中的自定义集合类型不使用默认命名空间、名称、重复元素名称或键/值元素名称。）这些类型是为列表类型派生的空类型 <xref:System.Collections.Generic.List%601> 和字典类型的泛型字典。</span><span class="sxs-lookup"><span data-stu-id="26d73-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="26d73-216">例如，您可能在服务器上有以下类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="26d73-217">当导出并再次导入架构时，生成的客户端代码与下面类似（为便于阅读，显示的是字段而不是属性）。</span><span class="sxs-lookup"><span data-stu-id="26d73-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="26d73-218">您可能想要在生成的代码中使用与默认类型不同的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="26d73-219">例如，为了使数据成员易于绑定到用户界面组件，您可能想对它们使用泛型 <xref:System.ComponentModel.BindingList%601> ，而不使用常规数组。</span><span class="sxs-lookup"><span data-stu-id="26d73-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="26d73-220">若要选择要生成的集合类型，请在导入架构时，将要使用的集合类型的列表传递到 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 对象的 <xref:System.Runtime.Serialization.ImportOptions> 属性。</span><span class="sxs-lookup"><span data-stu-id="26d73-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="26d73-221">这些类型称为“引用的集合类型” \*\*。</span><span class="sxs-lookup"><span data-stu-id="26d73-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="26d73-222">当引用泛型类型时，这些类型必须要么是完全开放式泛型，要么是完全封闭式泛型。</span><span class="sxs-lookup"><span data-stu-id="26d73-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="26d73-223">当使用 Svcutil.exe 工具时，可以使用 **/collectionType** 命令行开关（简写形式是 **/ct**）来完成此引用。</span><span class="sxs-lookup"><span data-stu-id="26d73-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="26d73-224">请记住，还必须使用 **/reference** 开关（简写形式是 **/r**）指定引用的集合类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="26d73-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="26d73-225">如果此类型是泛型，则它后面必须跟有反引号和泛型参数的数目。</span><span class="sxs-lookup"><span data-stu-id="26d73-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="26d73-226">后面的引号（ \` ）不会与单引号（'）字符混淆。</span><span class="sxs-lookup"><span data-stu-id="26d73-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="26d73-227">你可以通过多次使用 **/collectionType** 开关来指定多个引用的集合类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="26d73-228">例如，使所有列表作为泛型 <xref:System.Collections.Generic.List%601>导入。</span><span class="sxs-lookup"><span data-stu-id="26d73-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="26d73-229">导入任意集合时，都会扫描这一引用的集合类型列表，如果找到一个最佳匹配集合，则会将该集合用作数据成员类型（对于非自定义集合）或可从中派生其他类型的基类型（对于自定义集合）。</span><span class="sxs-lookup"><span data-stu-id="26d73-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="26d73-230">字典只能与字典匹配，列表只能与列表匹配。</span><span class="sxs-lookup"><span data-stu-id="26d73-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="26d73-231">例如，如果您将泛型 <xref:System.ComponentModel.BindingList%601> 和 <xref:System.Collections.Hashtable> 添加到引用类型列表，则前面示例的生成客户端代码将类似于以下代码：</span><span class="sxs-lookup"><span data-stu-id="26d73-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="26d73-232">您可以将集合接口类型指定为引用的集合类型的一部分，但不能指定无效的集合类型（例如，没有 `Add` 方法或公共构造函数的类型）。</span><span class="sxs-lookup"><span data-stu-id="26d73-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="26d73-233">封闭式泛型被视为最佳匹配</span><span class="sxs-lookup"><span data-stu-id="26d73-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="26d73-234">（非泛型类型被视为与 `Object`的封闭式泛型等效）。</span><span class="sxs-lookup"><span data-stu-id="26d73-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="26d73-235">例如，如果 <xref:System.Collections.Generic.List%601> 的泛型 <xref:System.DateTime>、泛型 <xref:System.ComponentModel.BindingList%601> （开放式泛型）和 <xref:System.Collections.ArrayList> 类型是引用的集合类型，则会生成以下代码：</span><span class="sxs-lookup"><span data-stu-id="26d73-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="26d73-236">对于列表集合，只支持下面的表中的情况。</span><span class="sxs-lookup"><span data-stu-id="26d73-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="26d73-237">引用类型</span><span class="sxs-lookup"><span data-stu-id="26d73-237">Referenced type</span></span>|<span data-ttu-id="26d73-238">引用类型所实现的接口</span><span class="sxs-lookup"><span data-stu-id="26d73-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="26d73-239">示例</span><span class="sxs-lookup"><span data-stu-id="26d73-239">Example</span></span>|<span data-ttu-id="26d73-240">类型被视为：</span><span class="sxs-lookup"><span data-stu-id="26d73-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="26d73-241">非泛型或封闭式泛型（任意多个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="26d73-242">非泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="26d73-243">或</span><span class="sxs-lookup"><span data-stu-id="26d73-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="26d73-244">其中 T= `int`</span><span class="sxs-lookup"><span data-stu-id="26d73-244">where T= `int`</span></span>|<span data-ttu-id="26d73-245">`Object` 的封闭式泛型（例如， `IList<object>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="26d73-246">非泛型或封闭式泛型（可以有任意多个参数，而且这些参数不是必须与集合类型匹配）</span><span class="sxs-lookup"><span data-stu-id="26d73-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="26d73-247">封闭式泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="26d73-248">或</span><span class="sxs-lookup"><span data-stu-id="26d73-248">or</span></span><br /><br /> <span data-ttu-id="26d73-249">`MyType<T> : IList<string>` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="26d73-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="26d73-250">封闭式泛型（例如 `IList<string>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="26d73-251">可以有任意多个参数的封闭式泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="26d73-252">使用该类型的任何一个参数的开放式泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="26d73-253">其中 T=`int`，U=`string`，V=`bool`</span><span class="sxs-lookup"><span data-stu-id="26d73-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="26d73-254">封闭式泛型（例如 `IList<string>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="26d73-255">具有一个参数的开放式泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-255">Open generic with one parameter</span></span>|<span data-ttu-id="26d73-256">使用该类型的参数的开放式泛型</span><span class="sxs-lookup"><span data-stu-id="26d73-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="26d73-257">`MyType<T> : IList<T>`，T 是开放式的</span><span class="sxs-lookup"><span data-stu-id="26d73-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="26d73-258">开放式泛型（例如 `IList<T>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="26d73-259">如果类型实现多个列表集合接口，则下列限制适用：</span><span class="sxs-lookup"><span data-stu-id="26d73-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="26d73-260">如果类型针对不同的类型多次实现泛型 <xref:System.Collections.Generic.IEnumerable%601> （或它的派生接口），则该类型不会被视为有效的引用集合类型，因此会被忽略。</span><span class="sxs-lookup"><span data-stu-id="26d73-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="26d73-261">即使有些实现是无效的或者使用开放式泛型，也将如此。</span><span class="sxs-lookup"><span data-stu-id="26d73-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="26d73-262">例如，实现 <xref:System.Collections.Generic.IEnumerable%601> 的泛型 `int` 以及 T 的泛型 <xref:System.Collections.Generic.IEnumerable%601> 的类型绝不会用作 `int` 或其他任何类型的引用集合，无论该类型是否具有接受 `Add` 的 `int` 方法和/或接受类型 T 的参数的 `Add` 方法，都将如此。</span><span class="sxs-lookup"><span data-stu-id="26d73-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="26d73-263">如果该类型实现一个泛型集合接口和 <xref:System.Collections.IList>，则该类型将绝不会用作引用的集合类型，除非该泛型集合接口是 <xref:System.Object>类型的封闭式泛型。</span><span class="sxs-lookup"><span data-stu-id="26d73-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="26d73-264">对于字典集合，只支持下面的表中的情况。</span><span class="sxs-lookup"><span data-stu-id="26d73-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="26d73-265">引用类型</span><span class="sxs-lookup"><span data-stu-id="26d73-265">Referenced type</span></span>|<span data-ttu-id="26d73-266">引用类型所实现的接口</span><span class="sxs-lookup"><span data-stu-id="26d73-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="26d73-267">示例</span><span class="sxs-lookup"><span data-stu-id="26d73-267">Example</span></span>|<span data-ttu-id="26d73-268">类型被视为</span><span class="sxs-lookup"><span data-stu-id="26d73-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="26d73-269">非泛型或封闭式泛型（任意多个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="26d73-270">或</span><span class="sxs-lookup"><span data-stu-id="26d73-270">or</span></span><br /><br /> <span data-ttu-id="26d73-271">`MyType<T> : IDictionary` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="26d73-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="26d73-272">封闭式泛型 `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="26d73-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="26d73-273">封闭式泛型（任意多个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26d73-274"><xref:System.Collections.Generic.IDictionary%602>，封闭式</span><span class="sxs-lookup"><span data-stu-id="26d73-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="26d73-275">`MyType<T> : IDictionary<string, bool>` 其中 T=`int`</span><span class="sxs-lookup"><span data-stu-id="26d73-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="26d73-276">封闭式泛型（例如 `IDIctionary<string,bool>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="26d73-277">封闭式泛型（任意多个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26d73-278">泛型 <xref:System.Collections.Generic.IDictionary%602>，键或值中的一个是封闭式的，另一个是开放式的，并使用类型的某个参数</span><span class="sxs-lookup"><span data-stu-id="26d73-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="26d73-279">`MyType<T,U,V> : IDictionary<string,V>` ，其中 T=`int`，U=`float`，V=`bool`</span><span class="sxs-lookup"><span data-stu-id="26d73-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="26d73-280">或</span><span class="sxs-lookup"><span data-stu-id="26d73-280">or</span></span><br /><br /> <span data-ttu-id="26d73-281">`MyType<Z> : IDictionary<Z,bool>` ，其中 Z=`string`</span><span class="sxs-lookup"><span data-stu-id="26d73-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="26d73-282">封闭式泛型（例如 `IDictionary<string,bool>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="26d73-283">封闭式泛型（任意多个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="26d73-284">泛型 <xref:System.Collections.Generic.IDictionary%602>，键和值均是开放式的，且每个都使用类型的一个参数</span><span class="sxs-lookup"><span data-stu-id="26d73-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="26d73-285">`MyType<T,U,V> : IDictionary<V,U>` 其中 T=`int`，U=`bool`，V=`string`</span><span class="sxs-lookup"><span data-stu-id="26d73-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="26d73-286">封闭式泛型（例如 `IDictionary<string,bool>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="26d73-287">开放式泛型（两个参数）</span><span class="sxs-lookup"><span data-stu-id="26d73-287">Open generic (two parameters)</span></span>|<span data-ttu-id="26d73-288">开放式泛型 <xref:System.Collections.Generic.IDictionary%602>，按显示顺序使用类型的两个泛型参数</span><span class="sxs-lookup"><span data-stu-id="26d73-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="26d73-289">`MyType<K,V> : IDictionary<K,V>`，K 和 V 均是开放式的</span><span class="sxs-lookup"><span data-stu-id="26d73-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="26d73-290">开放式泛型（例如 `IDictionary<K,V>`）</span><span class="sxs-lookup"><span data-stu-id="26d73-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="26d73-291">如果类型同时实现 <xref:System.Collections.IDictionary> 和泛型 <xref:System.Collections.Generic.IDictionary%602>，则只将考虑泛型 <xref:System.Collections.Generic.IDictionary%602> 。</span><span class="sxs-lookup"><span data-stu-id="26d73-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="26d73-292">不支持引用部分泛型类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="26d73-293">不允许重复，例如，不能将 <xref:System.Collections.Generic.List%601> 的泛型 `Integer` 和 `Integer` 的泛型集合都添加到 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>中，因此这会使得当在架构中找到整数列表时无法确定使用其中的哪一个。</span><span class="sxs-lookup"><span data-stu-id="26d73-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="26d73-294">只有当架构中存在暴露重复问题的类型时，才会检测重复项。</span><span class="sxs-lookup"><span data-stu-id="26d73-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="26d73-295">例如，如果导入的架构不包含整数列表，则在 <xref:System.Collections.Generic.List%601> 中可以同时具有 `Integer` 的泛型 `Integer` 和 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>的泛型集合，但是两者都没有任何效果。</span><span class="sxs-lookup"><span data-stu-id="26d73-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="26d73-296">高级集合规则</span><span class="sxs-lookup"><span data-stu-id="26d73-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="26d73-297">序列化集合</span><span class="sxs-lookup"><span data-stu-id="26d73-297">Serializing Collections</span></span>

<span data-ttu-id="26d73-298">下面是集合序列化规则的列表：</span><span class="sxs-lookup"><span data-stu-id="26d73-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="26d73-299">允许组合集合类型（具有集合的集合）。</span><span class="sxs-lookup"><span data-stu-id="26d73-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="26d73-300">交错数组被视为集合的集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="26d73-301">不支持多维数组。</span><span class="sxs-lookup"><span data-stu-id="26d73-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="26d73-302">字节数组和 <xref:System.Xml.XmlNode> 数组是特殊的数组类型，将被视为基元，而不是集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="26d73-303">序列化字节数组会产生单个包含一个 Base64 编码数据块的 XML 元素，而不是为每个字节都生成一个单独的元素。</span><span class="sxs-lookup"><span data-stu-id="26d73-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="26d73-304">有关如何处理的数组的详细信息 <xref:System.Xml.XmlNode> ，请参阅[数据协定中的 XML 和 ADO.NET 类型](xml-and-ado-net-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="26d73-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="26d73-305">当然，这些特殊类型本身可以参与集合：字节数组的数组会产生多个 XML 元素，其中每个元素都包含一个 Base64 编码数据块。</span><span class="sxs-lookup"><span data-stu-id="26d73-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="26d73-306">如果 <xref:System.Runtime.Serialization.DataContractAttribute> 属性应用于集合类型，则该类型会被视为常规数据协定类型，而不是集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="26d73-307">如果集合类型实现 <xref:System.Xml.Serialization.IXmlSerializable> 接口，下列规则适用（假定类型为 `myType:IList<string>, IXmlSerializable`）：</span><span class="sxs-lookup"><span data-stu-id="26d73-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="26d73-308">如果声明类型为 `IList<string>`，则将类型序列化为列表。</span><span class="sxs-lookup"><span data-stu-id="26d73-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="26d73-309">如果声明类型为 `myType`，则将该声明类型序列化为 `IXmlSerializable`。</span><span class="sxs-lookup"><span data-stu-id="26d73-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="26d73-310">如果该声明类型为 `IXmlSerializable`，则该声明类型将序列化为 `IXmlSerializable`，但前提是将 `myType` 添加到已知类型的列表。</span><span class="sxs-lookup"><span data-stu-id="26d73-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="26d73-311">使用下表中显示的方法对集合进行序列化和反序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="26d73-312">集合类型实现</span><span class="sxs-lookup"><span data-stu-id="26d73-312">Collection type implements</span></span>|<span data-ttu-id="26d73-313">序列化时调用的方法</span><span class="sxs-lookup"><span data-stu-id="26d73-313">Method(s) called on serialization</span></span>|<span data-ttu-id="26d73-314">反序列化时调用的方法</span><span class="sxs-lookup"><span data-stu-id="26d73-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="26d73-315">泛型 <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="26d73-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="26d73-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="26d73-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="26d73-317">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="26d73-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="26d73-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="26d73-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="26d73-319">泛型 <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="26d73-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="26d73-320">泛型 <xref:System.Collections.Generic.IList%601> 索引器</span><span class="sxs-lookup"><span data-stu-id="26d73-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="26d73-321">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="26d73-321">Generic Add</span></span>|
|<span data-ttu-id="26d73-322">泛型 <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="26d73-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="26d73-323">枚举器</span><span class="sxs-lookup"><span data-stu-id="26d73-323">Enumerator</span></span>|<span data-ttu-id="26d73-324">泛型 Add</span><span class="sxs-lookup"><span data-stu-id="26d73-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="26d73-325"><xref:System.Collections.IList> 索引器</span><span class="sxs-lookup"><span data-stu-id="26d73-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="26d73-326">泛型 <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="26d73-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="26d73-327">一个称为 `Add` 的非静态方法，它采用一个相应类型（泛型参数的类型或者它的某个基类型）的参数。</span><span class="sxs-lookup"><span data-stu-id="26d73-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="26d73-328">必须存在这样的方法，序列化程序才能在序列化和反序列化期间，都将集合类型视为集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="26d73-329"><xref:System.Collections.IEnumerable> （因此也包括派生自它的 <xref:System.Collections.ICollection>）</span><span class="sxs-lookup"><span data-stu-id="26d73-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="26d73-330">一个名为 `Add` 的非静态方法，它采用一个 `Object`类型的参数。</span><span class="sxs-lookup"><span data-stu-id="26d73-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="26d73-331">必须存在这样的方法，序列化程序才能在序列化和反序列化期间，都将集合类型视为集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="26d73-332">上表按优先级从高到低的顺序列出集合接口。</span><span class="sxs-lookup"><span data-stu-id="26d73-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="26d73-333">现举例说明这样列出的含义：如果一个类型同时实现 <xref:System.Collections.IList> 和泛型 <xref:System.Collections.Generic.IEnumerable%601>，则集合将按照 <xref:System.Collections.IList> 规则进行序列化和反序列化：</span><span class="sxs-lookup"><span data-stu-id="26d73-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="26d73-334">在反序列化时，将通过调用无参数的构造函数来反序列化所有集合，序列化程序在序列化和反序列化过程中将集合类型视为集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="26d73-335">如果同一泛型集合接口实现多次（例如，如果一个类型既实现 <xref:System.Collections.Generic.ICollection%601> 的泛型 `Integer` ，也实现 <xref:System.Collections.Generic.ICollection%601> 的泛型 <xref:System.String>），并且找不到更高优先级的接口，则该集合将不会被视为有效集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="26d73-336">集合类型可以应用 <xref:System.SerializableAttribute> 属性，并且可以实现 <xref:System.Runtime.Serialization.ISerializable> 接口。</span><span class="sxs-lookup"><span data-stu-id="26d73-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="26d73-337">两者都将被忽略。</span><span class="sxs-lookup"><span data-stu-id="26d73-337">Both of these are ignored.</span></span> <span data-ttu-id="26d73-338">但是，如果类型未充分满足集合类型要求（例如，缺少 `Add` 方法），则该类型将不会被视为集合类型，因此会使用 <xref:System.SerializableAttribute> 属性和 <xref:System.Runtime.Serialization.ISerializable> 接口来确定类型是否可以序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="26d73-339">为了自定义集合而向其应用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性会去掉上面的 <xref:System.SerializableAttribute> 回退机制。</span><span class="sxs-lookup"><span data-stu-id="26d73-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="26d73-340">在这种情况下，如果自定义集合不满足集合类型要求，将会引发 <xref:System.Runtime.Serialization.InvalidDataContractException> 异常。</span><span class="sxs-lookup"><span data-stu-id="26d73-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="26d73-341">异常字符串通常包含说明给定类型不被视为有效集合（无 `Add` 方法、没有无参数的构造函数等）的原因的信息，因此，为调试目的应用该属性通常很有用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="26d73-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="26d73-342">集合命名</span><span class="sxs-lookup"><span data-stu-id="26d73-342">Collection Naming</span></span>

<span data-ttu-id="26d73-343">以下是集合命名规则的列表：</span><span class="sxs-lookup"><span data-stu-id="26d73-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="26d73-344">所有字典集合数据协定以及包含基元类型的列表集合数据协定的默认命名空间均为， `http://schemas.microsoft.com/2003/10/Serialization/Arrays` 除非使用命名空间重写。</span><span class="sxs-lookup"><span data-stu-id="26d73-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="26d73-345">为此，映射到内置 XSD 类型的类型以及 `char`、 `Timespan`和 `Guid` 类型都将被视为基元。</span><span class="sxs-lookup"><span data-stu-id="26d73-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="26d73-346">包含非基元类型的集合类型的默认命名空间如果未使用 Namespace 重写，则与集合中包含的类型的数据协定命名空间相同。</span><span class="sxs-lookup"><span data-stu-id="26d73-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="26d73-347">列表集合数据协定的默认名称如果未使用 Name 重写，则是“ArrayOf”字符串与集合中包含类型的数据协定名称的组合。</span><span class="sxs-lookup"><span data-stu-id="26d73-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="26d73-348">例如，某个整数泛型列表的数据协定名称是“ArrayOfint”。</span><span class="sxs-lookup"><span data-stu-id="26d73-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="26d73-349">请记住， `Object` 的数据协定名称是“anyType”，因此诸如 <xref:System.Collections.ArrayList> 这样的非泛型列表的数据协定名称是“ArrayOfanyType”。</span><span class="sxs-lookup"><span data-stu-id="26d73-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="26d73-350">字典集合数据协定的默认名称如果未使用 `Name`重写，则是“ArrayOfKeyValueOf”字符串与键类型的数据协定名称以及值类型的数据协定名称（按此顺序）的组合。</span><span class="sxs-lookup"><span data-stu-id="26d73-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="26d73-351">例如，String 和 Integer 的泛型字典的数据协定名称是“ArrayOfKeyValueOfstringint”。</span><span class="sxs-lookup"><span data-stu-id="26d73-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="26d73-352">此外，如果键或值类型不是基元类型，则键和值类型的数据协定命名空间的命名空间哈希将会追加到名称的末尾。</span><span class="sxs-lookup"><span data-stu-id="26d73-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="26d73-353">有关命名空间哈希的详细信息，请参阅[数据协定名称](data-contract-names.md)。</span><span class="sxs-lookup"><span data-stu-id="26d73-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="26d73-354">每个字典集合数据协定都有一个表示字典中的一项的伴随数据协定。</span><span class="sxs-lookup"><span data-stu-id="26d73-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="26d73-355">除“ArrayOf”前缀外，它的名称与字典数据协定相同，并且命名空间也与字典数据协定相同。</span><span class="sxs-lookup"><span data-stu-id="26d73-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="26d73-356">例如，对于“ArrayOfKeyValueOfstringint”字典数据协定，“KeyValueofstringint”数据协定表示字典中的一项。</span><span class="sxs-lookup"><span data-stu-id="26d73-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="26d73-357">您可以使用 `ItemName` 属性来自定义该数据协定的名称，具体说明请见下一部分。</span><span class="sxs-lookup"><span data-stu-id="26d73-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="26d73-358">[Data Contract Names](data-contract-names.md)中介绍的泛型类型命名规则完全适用于集合类型，也就是说，你可以使用 Name 内的大括号来表示泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="26d73-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="26d73-359">但是，括号内的数字指泛型参数，而不是指集合中包含的类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="26d73-360">集合自定义</span><span class="sxs-lookup"><span data-stu-id="26d73-360">Collection Customization</span></span>

<span data-ttu-id="26d73-361"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性的下列用法是被禁止的，这些用法会导致 <xref:System.Runtime.Serialization.InvalidDataContractException> 异常：</span><span class="sxs-lookup"><span data-stu-id="26d73-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="26d73-362">向已应用 <xref:System.Runtime.Serialization.DataContractAttribute> 属性的类型或者它的某个派生类型应用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性。</span><span class="sxs-lookup"><span data-stu-id="26d73-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="26d73-363">向实现 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 接口的类型应用 <xref:System.Xml.Serialization.IXmlSerializable> 属性。</span><span class="sxs-lookup"><span data-stu-id="26d73-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="26d73-364">向非集合类型应用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性。</span><span class="sxs-lookup"><span data-stu-id="26d73-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="26d73-365">试图对应用于非字典类型的 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> 属性设置 <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> 或 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="26d73-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="26d73-366">多态性规则</span><span class="sxs-lookup"><span data-stu-id="26d73-366">Polymorphism Rules</span></span>

<span data-ttu-id="26d73-367">如前所述，使用 <xref:System.Runtime.Serialization.CollectionDataContractAttribute> 属性自定义集合可能会影响集合的可互换性。</span><span class="sxs-lookup"><span data-stu-id="26d73-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="26d73-368">如果两个自定义集合类型的名称、命名空间、项名称以及键和值名称（如果它们是字典集合）均匹配，则只能被视为等效。</span><span class="sxs-lookup"><span data-stu-id="26d73-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="26d73-369">由于自定义，可能意外地在本应使用某个集合数据协定的地方使用另一个集合数据协定。</span><span class="sxs-lookup"><span data-stu-id="26d73-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="26d73-370">应避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="26d73-370">This should be avoided.</span></span> <span data-ttu-id="26d73-371">请参见以下类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="26d73-372">在本例中，可以将 `Marks1` 的实例指定给 `testMarks`。</span><span class="sxs-lookup"><span data-stu-id="26d73-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="26d73-373">但是，不应使用 `Marks2` ，因为其数据协定不被视为与 `IList<int>` 数据协定等效。</span><span class="sxs-lookup"><span data-stu-id="26d73-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="26d73-374">数据协定名称为 "Marks2" 而不是 "ArrayOfint"，重复元素名称为 " \<mark> "，而不是 " \<int> "。</span><span class="sxs-lookup"><span data-stu-id="26d73-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="26d73-375">下表中的规则适用于集合的多态指定。</span><span class="sxs-lookup"><span data-stu-id="26d73-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="26d73-376">声明的类型</span><span class="sxs-lookup"><span data-stu-id="26d73-376">Declared type</span></span>|<span data-ttu-id="26d73-377">指定非自定义集合</span><span class="sxs-lookup"><span data-stu-id="26d73-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="26d73-378">指定自定义集合</span><span class="sxs-lookup"><span data-stu-id="26d73-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="26d73-379">对象</span><span class="sxs-lookup"><span data-stu-id="26d73-379">Object</span></span>|<span data-ttu-id="26d73-380">协定名称序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-380">Contract name is serialized.</span></span>|<span data-ttu-id="26d73-381">协定名称序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26d73-382">使用自定义。</span><span class="sxs-lookup"><span data-stu-id="26d73-382">Customization is used.</span></span>|
|<span data-ttu-id="26d73-383">集合接口</span><span class="sxs-lookup"><span data-stu-id="26d73-383">Collection interface</span></span>|<span data-ttu-id="26d73-384">协定名称不序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-384">Contract name is not serialized.</span></span>|<span data-ttu-id="26d73-385">协定名称不序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="26d73-386">不使用自定义。\*</span><span class="sxs-lookup"><span data-stu-id="26d73-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="26d73-387">非自定义集合</span><span class="sxs-lookup"><span data-stu-id="26d73-387">Non-customized collection</span></span>|<span data-ttu-id="26d73-388">协定名称不序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-388">Contract name is not serialized.</span></span>|<span data-ttu-id="26d73-389">协定名称序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26d73-390">使用自定义。\*\*</span><span class="sxs-lookup"><span data-stu-id="26d73-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="26d73-391">自定义集合</span><span class="sxs-lookup"><span data-stu-id="26d73-391">Customized collection</span></span>|<span data-ttu-id="26d73-392">协定名称序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-392">Contract name is serialized.</span></span> <span data-ttu-id="26d73-393">不使用自定义。\*\*</span><span class="sxs-lookup"><span data-stu-id="26d73-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="26d73-394">协定名称序列化。</span><span class="sxs-lookup"><span data-stu-id="26d73-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="26d73-395">使用已分配类型的自定义。\*\*</span><span class="sxs-lookup"><span data-stu-id="26d73-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="26d73-396">\*对于 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类，在这种情况下将使用自定义。</span><span class="sxs-lookup"><span data-stu-id="26d73-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="26d73-397">在这种情况下 <xref:System.Runtime.Serialization.NetDataContractSerializer> 类还将序列化实际类型名称，以便反序列化按预期的方式工作。</span><span class="sxs-lookup"><span data-stu-id="26d73-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="26d73-398">\*\*这种情况会导致架构无效的实例，因此应避免这样做。</span><span class="sxs-lookup"><span data-stu-id="26d73-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="26d73-399">在序列化协定名称的情况下，指定的集合类型应当在已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="26d73-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="26d73-400">反之亦然：在不序列化协定名称的情况下，不需要将该类型添加到已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="26d73-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="26d73-401">可以将派生类型的数组指定给基类型数组。</span><span class="sxs-lookup"><span data-stu-id="26d73-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="26d73-402">在这种情况下，会针对每个重复元素序列化派生类型的协定名称。</span><span class="sxs-lookup"><span data-stu-id="26d73-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="26d73-403">例如，如果类型 `Book` 派生自类型 `LibraryItem`，则您可以将 `Book` 的数组指定给 `LibraryItem`的数组。</span><span class="sxs-lookup"><span data-stu-id="26d73-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="26d73-404">这不适用于其他集合类型。</span><span class="sxs-lookup"><span data-stu-id="26d73-404">This does not apply to other collection types.</span></span> <span data-ttu-id="26d73-405">例如，您不能将 `Generic List of Book` 指定给 `Generic List of LibraryItem`。</span><span class="sxs-lookup"><span data-stu-id="26d73-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="26d73-406">但可以指定包含 `Generic List of LibraryItem` 实例的 `Book` 。</span><span class="sxs-lookup"><span data-stu-id="26d73-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="26d73-407">在使用数组和非数组的情况下， `Book` 都应当在已知类型列表中。</span><span class="sxs-lookup"><span data-stu-id="26d73-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="26d73-408">集合和对象引用保存</span><span class="sxs-lookup"><span data-stu-id="26d73-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="26d73-409">当序列化程序在保存对象引用的模式下工作时，对象引用保存也适用于集合。</span><span class="sxs-lookup"><span data-stu-id="26d73-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="26d73-410">具体而言，会为整个集合以及集合中包含的各个项保存对象标识。</span><span class="sxs-lookup"><span data-stu-id="26d73-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="26d73-411">对于字典，会为键/值对对象以及各个键和值对象保存对象标识。</span><span class="sxs-lookup"><span data-stu-id="26d73-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="26d73-412">另请参阅</span><span class="sxs-lookup"><span data-stu-id="26d73-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
