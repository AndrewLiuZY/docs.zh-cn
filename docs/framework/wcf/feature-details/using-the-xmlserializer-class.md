---
title: 使用 XmlSerializer 类
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: 2ef2d0eefb571f64040fabd16fd65fdfde7a626d
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/09/2020
ms.locfileid: "84600200"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="ec6d2-102">使用 XmlSerializer 类</span><span class="sxs-lookup"><span data-stu-id="ec6d2-102">Using the XmlSerializer Class</span></span>

<span data-ttu-id="ec6d2-103">Windows Communication Foundation （WCF）可以使用两种不同的序列化技术，将应用程序中的数据转换为在客户端和服务之间传输的 XML，这是一个称为序列化的进程。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-103">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="ec6d2-104">DataContractSerializer 为默认序列化程序</span><span class="sxs-lookup"><span data-stu-id="ec6d2-104">DataContractSerializer as the Default</span></span>

<span data-ttu-id="ec6d2-105">默认情况下，WCF 使用 <xref:System.Runtime.Serialization.DataContractSerializer> 类来序列化数据类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-105">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="ec6d2-106">此序列化程序支持下列类型：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-106">This serializer supports the following types:</span></span>

- <span data-ttu-id="ec6d2-107">基元类型（如：整数、字符串和字节数组）以及某些特殊类型（如 <xref:System.Xml.XmlElement> 和 <xref:System.DateTime>），这些特殊类型也被视为基元类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-107">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="ec6d2-108">数据协定类型（用 <xref:System.Runtime.Serialization.DataContractAttribute> 属性标记的类型）。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-108">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="ec6d2-109">用 <xref:System.SerializableAttribute> 属性标记的类型，包括实现 <xref:System.Runtime.Serialization.ISerializable> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-109">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="ec6d2-110">实现 <xref:System.Xml.Serialization.IXmlSerializable> 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-110">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="ec6d2-111">许多常见集合类型，包括许多泛型集合类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-111">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="ec6d2-112">许多 .NET Framework 类型属于后两个类别，因此是可序列化的。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-112">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="ec6d2-113">可序列化类型的数组也可序列化。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-113">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="ec6d2-114">有关完整列表，请参阅[在服务协定中指定数据传输](specifying-data-transfer-in-service-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-114">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="ec6d2-115"><xref:System.Runtime.Serialization.DataContractSerializer>与数据协定类型一起使用的建议方法是编写新的 WCF 服务。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-115">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="ec6d2-116">有关详细信息，请参阅[使用数据协定](using-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-116">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="ec6d2-117">使用 XmlSerializer 类的时机</span><span class="sxs-lookup"><span data-stu-id="ec6d2-117">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="ec6d2-118">WCF 还支持 <xref:System.Xml.Serialization.XmlSerializer> 类。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-118">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="ec6d2-119"><xref:System.Xml.Serialization.XmlSerializer>类对于 WCF 不是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-119">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="ec6d2-120">它与 ASP.NET Web 服务使用的序列化引擎相同。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-120">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="ec6d2-121"><xref:System.Xml.Serialization.XmlSerializer> 类支持的类型少于 <xref:System.Runtime.Serialization.DataContractSerializer> 类支持的类型，但它允许对生成的 XML 进行更多的控制，并且支持更多的 XML 架构定义语言 (XSD) 标准。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-121">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="ec6d2-122">它也不要求针对可序列化类型的任何声明性属性。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-122">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="ec6d2-123">有关详细信息，请参阅 .NET Framework 文档中的 XML 序列化主题。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-123">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="ec6d2-124"><xref:System.Xml.Serialization.XmlSerializer> 类并不支持数据协定类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-124">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="ec6d2-125">当使用 Svcutil.exe 或 Visual Studio 中的**添加服务引用**功能生成第三方服务的客户端代码，或访问第三方架构时，系统会自动选择相应的序列化程序。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-125">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="ec6d2-126">如果架构与 <xref:System.Runtime.Serialization.DataContractSerializer> 不兼容，则选择 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-126">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="ec6d2-127">手动切换到 XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="ec6d2-127">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="ec6d2-128">有时候，您也许必须手动切换到 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-128">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="ec6d2-129">例如，在以下情况下可能需要这样做：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-129">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="ec6d2-130">在将应用程序从 ASP.NET Web 服务迁移到 WCF 时，您可能需要重用现有的、与 <xref:System.Xml.Serialization.XmlSerializer> 兼容的类型，而不是创建新的数据协定类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-130">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="ec6d2-131">当对出现在消息中的 XML 的精确控制很重要，而 Web 服务描述语言 (WSDL) 文档不可用时，例如，在使用必须遵循某个已标准化且已发布的架构（与 DataContractSerializer 不兼容）的类型来创建服务时。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-131">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="ec6d2-132">创建遵循旧式 SOAP 编码标准的服务时。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-132">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="ec6d2-133">在这些情况和其他情况下，你可以通过将 <xref:System.Xml.Serialization.XmlSerializer> 属性应用于你的服务来手动切换到 `XmlSerializerFormatAttribute` 类，如以下代码所示。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-133">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="ec6d2-134">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="ec6d2-134">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="ec6d2-135">切换序列化引擎时需要小心，这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-135">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="ec6d2-136">根据所使用的序列化程序，相同的类型可以序列化为不同的 XML。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-136">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="ec6d2-137">如果意外使用了错误的序列化程序，则可能会公开类型中您不希望公开的信息。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-137">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="ec6d2-138">例如，在序列化数据协定类型时，<xref:System.Runtime.Serialization.DataContractSerializer> 类只序列化用 <xref:System.Runtime.Serialization.DataMemberAttribute> 属性标记的成员。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-138">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="ec6d2-139"><xref:System.Xml.Serialization.XmlSerializer> 类序列化任何公共成员。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-139">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="ec6d2-140">请看以下代码中的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-140">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="ec6d2-141">如果在选择了 <xref:System.Xml.Serialization.XmlSerializer> 类的服务协定中不慎使用了该类型，则将序列化 `creditCardNumber` 成员，这可能并不是想要的结果。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-141">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="ec6d2-142">即使 <xref:System.Runtime.Serialization.DataContractSerializer> 类为默认值，您也可以通过将 <xref:System.ServiceModel.DataContractFormatAttribute> 属性应用于服务协定类型来为您的服务显式选择此类（虽然从不要求进行此项操作）。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-142">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="ec6d2-143">用于服务的序列化程序是协定的不可分割的一部分，你无法通过选择不同的绑定或更改其他配置设置来对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-143">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="ec6d2-144">此外，在使用 <xref:System.Xml.Serialization.XmlSerializer> 类时还需注意以下重要安全事项。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-144">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="ec6d2-145">首先，强烈建议使用类的任何 WCF 应用程序 <xref:System.Xml.Serialization.XmlSerializer> 都使用受泄露的密钥进行签名。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-145">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="ec6d2-146">在执行手动切换到 <xref:System.Xml.Serialization.XmlSerializer> 和执行自动切换（通过 Svcutil.exe、添加服务引用或类似工具）时都适合采用此建议。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-146">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="ec6d2-147">这是因为 <xref:System.Xml.Serialization.XmlSerializer> 序列化引擎支持加载*预先生成的序列化程序集*，只要这些程序集与应用程序具有相同的密钥进行签名。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-147">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="ec6d2-148">如果某恶意程序集的名称与放置在应用程序文件夹或全局程序集缓存中的预生成序列化程序集的预期名称相匹配，则未签名的应用程序对于此类恶意程序集的攻击完全没有防御能力。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-148">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="ec6d2-149">当然，攻击者必须首先获取对这两个位置中某个位置的写权限才能尝试进行攻击。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-149">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="ec6d2-150">您使用 <xref:System.Xml.Serialization.XmlSerializer> 时存在的另一个威胁与系统临时文件夹的写权限有关。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-150">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="ec6d2-151"><xref:System.Xml.Serialization.XmlSerializer>序列化引擎创建并使用此文件夹中的临时*序列化程序集*。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-151">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="ec6d2-152">你应该注意，任何对临时文件夹具有写权限的进程都可能用恶意代码覆盖这些序列化程序集。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-152">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="ec6d2-153">XmlSerializer 支持的规则</span><span class="sxs-lookup"><span data-stu-id="ec6d2-153">Rules for XmlSerializer support</span></span>

<span data-ttu-id="ec6d2-154">您不能直接将与兼容 <xref:System.Xml.Serialization.XmlSerializer> 的属性应用于协定操作参数或返回值。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-154">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="ec6d2-155">但是，可将这些属性应用于类型化消息（消息协定正文部分），如以下代码所示。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-155">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="ec6d2-156">当应用于类型化消息成员时，这些属性 (Attribute) 将覆盖与类型化消息属性 (Attribute) 相冲突的属性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-156">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="ec6d2-157">例如，在下列代码中，`ElementName` 覆盖 `Name`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-157">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="ec6d2-158">使用 <xref:System.ServiceModel.MessageHeaderArrayAttribute> 时不支持 <xref:System.Xml.Serialization.XmlSerializer> 属性。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-158">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="ec6d2-159">在这种情况下， <xref:System.Xml.Serialization.XmlSerializer> 会引发下面的异常，该异常在 WCF 之前发布： "在架构的顶级声明的元素不能有 `maxOccurs` > 1。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-159">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="ec6d2-160">使用 `XmlArray` 或 `XmlArrayItem` 而不是 `XmlElementAttribute`，或使用换行的参数样式为“more”提供包装元素。”</span><span class="sxs-lookup"><span data-stu-id="ec6d2-160">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="ec6d2-161">如果您接收到此异常，请调查是否属于这种情况。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-161">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="ec6d2-162">WCF 不支持 <xref:System.Xml.Serialization.SoapIncludeAttribute> <xref:System.Xml.Serialization.XmlIncludeAttribute> 消息协定和操作协定中的和特性; 请改用 <xref:System.Runtime.Serialization.KnownTypeAttribute> 特性。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-162">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="ec6d2-163">用于实现 IXmlSerializable 接口的类型</span><span class="sxs-lookup"><span data-stu-id="ec6d2-163">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="ec6d2-164">`IXmlSerializable` 完全支持实现 `DataContractSerializer` 接口的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-164">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="ec6d2-165"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性应始终应用于这些类型以控制它们的架构。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-165">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="ec6d2-166">如果您要序列化多态类型，则必须将 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 应用于该类型以确保序列化正确的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-166">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="ec6d2-167">实现 `IXmlSerializable` 的类型有以下三种：表示任意内容的类型、表示单一元素的类型和旧的 <xref:System.Data.DataSet> 类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-167">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="ec6d2-168">内容类型使用由 `XmlSchemaProviderAttribute` 属性指定的架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-168">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="ec6d2-169">该方法不返回 `null`，并且特性上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 属性将保留为它的默认值 `false`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-169">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="ec6d2-170">这是 `IXmlSerializable` 类型的最常见的用法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-170">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="ec6d2-171">当 `IXmlSerializable` 类型必须控制其根元素名称时，使用元素类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-171">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="ec6d2-172">若要将某类型标记为元素类型，请将 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> 特性上的 <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> 属性设置为 `true`，或者从架构提供程序方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-172">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="ec6d2-173">对于元素类型，具有架构提供程序方法是可选的 – 您可以在 `null` 中指定 `XmlSchemaProviderAttribute` 而不指定方法名称。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-173">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="ec6d2-174">但是，如果 `IsAny` 为 `true`，并且已指定了架构提供程序方法，则该方法必须返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-174">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="ec6d2-175">旧 <xref:System.Data.DataSet> 类型为没有使用 `IXmlSerializable` 特性标记的 `XmlSchemaProviderAttribute` 类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-175">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="ec6d2-176">相反，它们依赖于架构生成的 <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-176">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="ec6d2-177">此模式用于 `DataSet` 类型，其类型化数据集在 .NET Framework 的早期版本中派生了一个类，但现在它已过时，并且只有旧版本才支持它。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-177">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="ec6d2-178">不要依赖于此模式，并始终将 `XmlSchemaProviderAttribute` 应用于 `IXmlSerializable` 类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-178">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="ec6d2-179">IXmlSerializable 内容类型</span><span class="sxs-lookup"><span data-stu-id="ec6d2-179">IXmlSerializable Content Types</span></span>

<span data-ttu-id="ec6d2-180">如果序列化某类型的数据成员，而该类型实现 `IXmlSerializable` 且是以前定义的内容类型，则序列化程序编写该数据成员的包装元素，并将控制权传递给 <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-180">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="ec6d2-181"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 实现可以编写任何 XML，其中包括将特性添加到包装元素。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-181">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="ec6d2-182">`WriteXml` 完成后，序列化程序将关闭该元素。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-182">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="ec6d2-183">如果反序列化某类型的数据成员，而该类型实现 `IXmlSerializable` 且是以前定义的内容类型，则反序列化程序将 XML 读取器放在该数据成员的包装元素上，并将控制权传递给 <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-183">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="ec6d2-184">该方法必须读取整个元素，包括起始和结束标记。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-184">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="ec6d2-185">请确保你的 `ReadXml` 代码可处理元素为空的情况。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-185">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="ec6d2-186">此外，您的 `ReadXml` 实现也不应该依赖于以特殊方式进行命名的包装元素。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-186">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="ec6d2-187">序列化程序所选的名称可以不同。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-187">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="ec6d2-188">允许以多元方式分配 `IXmlSerializable` 内容类型，例如，分配给 <xref:System.Object> 类型的数据成员。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-188">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="ec6d2-189">还允许类型实例为 null。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-189">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="ec6d2-190">最后，可以在启用对象图保留的情况下使用 `IXmlSerializable` 类型，以及和 <xref:System.Runtime.Serialization.NetDataContractSerializer> 一起使用。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-190">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="ec6d2-191">所有这些功能都要求 WCF 序列化程序将某些属性附加到包装元素（XML 架构实例命名空间中的 "nil" 和 "type" 和 WCF 特定的命名空间中的 "Id"、"Ref"、"Type" 和 "Assembly"）。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-191">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="ec6d2-192">实现 ReadXml 时要忽略的属性</span><span class="sxs-lookup"><span data-stu-id="ec6d2-192">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="ec6d2-193">在将控制权传递给 `ReadXml` 代码之前，反序列化程序将检查 XML 元素、检测这些特殊的 XML 属性，以及对它们进行操作。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-193">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="ec6d2-194">例如，如果“nil”为 `true`，则将反序列化一个 Null 值，并且不调用 `ReadXml`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-194">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="ec6d2-195">如果检测到多态性，则将反序列化该元素的内容，就好像该元素为其他类型一样。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-195">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="ec6d2-196">调用以多元方式分配的类型的 `ReadXml` 实现。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-196">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="ec6d2-197">在任何情况下，`ReadXml` 实现都应忽略这些特殊属性，因为它们均由反序列化程序处理。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-197">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="ec6d2-198">IXmlSerializable 内容类型的架构注意事项</span><span class="sxs-lookup"><span data-stu-id="ec6d2-198">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="ec6d2-199">当导出架构和 `IXmlSerializable` 内容类型时，将调用架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-199">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="ec6d2-200">并将 <xref:System.Xml.Schema.XmlSchemaSet> 传递给架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-200">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="ec6d2-201">该方法可以将任何有效架构添加到架构集中。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-201">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="ec6d2-202">该架构集将包含发生架构导出时已知的架构。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-202">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="ec6d2-203">当架构提供程序方法必须将某项添加到架构集时，它必须确定该集中是否已存在具有相应命名空间的 <xref:System.Xml.Schema.XmlSchema>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-203">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="ec6d2-204">如果已存在，则架构提供程序方法必须将新项添加到现有 `XmlSchema` 中。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-204">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="ec6d2-205">否则，它必须创建一个新的 `XmlSchema` 实例。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-205">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="ec6d2-206">如果使用的是 `IXmlSerializable` 类型数组，这是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-206">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="ec6d2-207">例如，如果您有一个 `IXmlSerializable` 类型，且已作为命名空间“B”中的类型“A”导出，则在调用架构提供程序方法时，架构集可能已包含保存“ArrayOfA”类型的“B”架构。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-207">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="ec6d2-208">除了将类型添加到 <xref:System.Xml.Schema.XmlSchemaSet>，内容类型的架构提供程序方法必须返回非空值。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-208">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="ec6d2-209">它可能返回 <xref:System.Xml.XmlQualifiedName>，指定用于给定 `IXmlSerializable` 类型的架构类型名称。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-209">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="ec6d2-210">此限定名称也将用作数据协定名称和该类型的命名空间。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-210">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="ec6d2-211">返回架构提供程序方法时允许立即返回架构集中不存在的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-211">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="ec6d2-212">但是，导出所有相关类型（调用 <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> 方法中有关 <xref:System.Runtime.Serialization.XsdDataContractExporter> 的所有相关类型并访问 <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> 属性）时，该类型应该存在于架构集中。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-212">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="ec6d2-213">在进行所有相关的 `Schemas` 调用之前访问 `Export` 属性可能会导致 <xref:System.Xml.Schema.XmlSchemaException>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-213">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="ec6d2-214">有关导出过程的详细信息，请参阅[从类导出架构](exporting-schemas-from-classes.md)。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-214">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="ec6d2-215">架构提供程序方法也可以返回要使用的 <xref:System.Xml.Schema.XmlSchemaType>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-215">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="ec6d2-216">该类型可能是匿名的，也可能不是。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-216">The type may or may not be anonymous.</span></span> <span data-ttu-id="ec6d2-217">如果它是匿名的，则每次将 `IXmlSerializable` 类型用作数据成员时，`IXmlSerializable` 类型的架构都将作为匿名类型导出。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-217">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="ec6d2-218">`IXmlSerializable` 类型仍具有数据协定名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-218">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="ec6d2-219">（这是根据[数据协定名称](data-contract-names.md)中所述来确定的，只不过 <xref:System.Runtime.Serialization.DataContractAttribute> 属性不能用于自定义名称。）如果它不是匿名的，则它必须是中的类型之一 `XmlSchemaSet` 。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-219">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="ec6d2-220">这种情况相当于返回该类型的 `XmlQualifiedName`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-220">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="ec6d2-221">另外，还将导出该类型的全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-221">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="ec6d2-222">如果该类型没有应用于它的 <xref:System.Xml.Serialization.XmlRootAttribute> 特性，则该元素具有与数据协定相同的名称和命名空间，且其“nillable”属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-222">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="ec6d2-223">这种情况的唯一例外是架构命名空间（ `http://www.w3.org/2001/XMLSchema` ）–如果该类型的数据协定在此命名空间中，则对应的全局元素在空白命名空间中，因为禁止将新元素添加到架构命名空间。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-223">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="ec6d2-224">如果该类型具有应用于它的 `XmlRootAttribute` 属性 (Attribute)，则将使用以下属性 (Property) 导出全局元素声明：<xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>、<xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> 和 <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-224">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="ec6d2-225">应用了 `XmlRootAttribute` 的默认值是数据协定名称、空命名空间和为 `true` 的“nillable”。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-225">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="ec6d2-226">同样的全局元素声明规则也适用于旧数据集类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-226">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="ec6d2-227">请注意，`XmlRootAttribute` 无法重写通过自定义代码添加的全局元素声明，无论是使用构架提供程序方法添加到 `XmlSchemaSet` 中的，还是通过旧数据集类型的 `GetSchema` 添加的。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-227">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="ec6d2-228">IXmlSerializable 元素类型</span><span class="sxs-lookup"><span data-stu-id="ec6d2-228">IXmlSerializable Element Types</span></span>

<span data-ttu-id="ec6d2-229">`IXmlSerializable` 元素类型将 `IsAny` 属性设为 `true`，或使它们的架构提供程序方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-229">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="ec6d2-230">序列化和反序列化元素类型与序列化和反序列化内容类型极其相似。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-230">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="ec6d2-231">但是，也有一些重要的区别：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-231">However, there are some important differences:</span></span>

- <span data-ttu-id="ec6d2-232">`WriteXml` 实现应只写入一个元素（当然，该元素可包含多个子元素）。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-232">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="ec6d2-233">它不应是此单个元素、多个同级元素或混合内容以外的写属性。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-233">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="ec6d2-234">该元素可能为空。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-234">The element may be empty.</span></span>

- <span data-ttu-id="ec6d2-235">`ReadXml` 实现不应读取包装元素。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-235">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="ec6d2-236">它应读取 `WriteXml` 生成的那一个元素。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-236">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="ec6d2-237">定期序列化元素类型时（例如，作为数据协定中的数据成员），序列化程序将在调用 `WriteXml` 之前输出包装元素，如同处理内容类型一样。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-237">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="ec6d2-238">然而，在顶层序列化元素类型时，序列化程序通常根本不输出 `WriteXml` 写入的元素周围的包装元素，除非在 `DataContractSerializer` 或 `NetDataContractSerializer` 构造函数中构造序列化程序时显式指定了根名称和命名空间。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-238">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="ec6d2-239">有关详细信息，请参阅[序列化和反序列](serialization-and-deserialization.md)化。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-239">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="ec6d2-240">如果在构造期间没有指定根名称和命名空间的情况下在顶层序列化元素类型，则 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> 和 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> 实质上不执行任何操作，且 <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> 将调用 `WriteXml`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-240">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="ec6d2-241">在此模式下，要序列化的对象不能为 `null`，且不能以多态形式进行分配。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-241">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="ec6d2-242">另外，不能启用对象图保留，也不能使用 `NetDataContractSerializer`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-242">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="ec6d2-243">如果在构造时没有指定根名称和命名空间的情况下在顶级反序列化某一元素类型，则在找到任何元素的开头时，<xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> 将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-243">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="ec6d2-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> 参数设置为 `verifyObjectName` 的 `true` 在行为上与实际读取该对象前 `IsStartObject` 的行为相同。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-244"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="ec6d2-245">然后，`ReadObject` 将控制传递到 `ReadXml` 方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-245">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="ec6d2-246">如上节所述，元素类型的导出架构与 `XmlElement` 类型的导出架构相同，只是架构提供程序方法可以像处理内容类型那样将任何其他架构添加到 <xref:System.Xml.Schema.XmlSchemaSet> 中。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-246">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="ec6d2-247">不允许使用元素类型的 `XmlRootAttribute` 属性，也从不为这些类型发出全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-247">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="ec6d2-248">与 XmlSerializer 的区别</span><span class="sxs-lookup"><span data-stu-id="ec6d2-248">Differences from the XmlSerializer</span></span>

<span data-ttu-id="ec6d2-249">`IXmlSerializable` 接口以及 `XmlSchemaProviderAttribute` 和 `XmlRootAttribute` 属性也都可以由 <xref:System.Xml.Serialization.XmlSerializer> 理解。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-249">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="ec6d2-250">但是，在数据协定模型中处理它们的方法有一些不同。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-250">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="ec6d2-251">下表汇总了重要区别：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-251">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="ec6d2-252">架构提供程序方法必须是公共方法才能在 `XmlSerializer` 中使用，但是它不必是公共方法即可在数据协定模型中使用。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-252">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="ec6d2-253">如果在数据协定模型中 `IsAny` 为 `true` 但是不具有 `XmlSerializer`，则调用架构提供程序方法。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-253">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="ec6d2-254">如果内容或旧数据集类型中没有 `XmlRootAttribute` 属性，则 `XmlSerializer` 将在空白命名空间中导出全局元素声明。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-254">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="ec6d2-255">如前面所述，在数据协定模型中，使用的命名空间通常是数据协定命名空间。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-255">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="ec6d2-256">创建与这两种序列化技术一起使用的类型时，请注意这些区别。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-256">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="ec6d2-257">导入 IXmlSerializable 架构</span><span class="sxs-lookup"><span data-stu-id="ec6d2-257">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="ec6d2-258">导入从 `IXmlSerializable` 类型生成的架构时，有以下几种可能：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-258">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="ec6d2-259">生成的架构可能是有效的数据协定架构，如[数据协定架构引用](data-contract-schema-reference.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-259">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="ec6d2-260">在此情况下，架构可以正常导入，并且将生成常规数据协定类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-260">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="ec6d2-261">生成的架构可能不是有效的数据协定架构。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-261">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="ec6d2-262">例如，架构提供程序方法生成的架构可能包含在数据协定模型中不受支持的 XML 特性。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-262">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="ec6d2-263">在此情况下，您可以将架构作为 `IXmlSerializable` 类型导入。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-263">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="ec6d2-264">默认情况下，此导入模式不处于启用状态，但可以轻松启用–例如，通过 `/importXmlTypes` 命令行开关转到 "行[元数据实用工具（svcutil.exe）](../servicemodel-metadata-utility-tool-svcutil-exe.md)"。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-264">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="ec6d2-265">[导入架构以生成类中对](importing-schema-to-generate-classes.md)此进行了详细介绍。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-265">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="ec6d2-266">请注意，您必须直接处理您的类型实例的 XML。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-266">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="ec6d2-267">您也可以考虑使用其他支持各种架构的不同序列化技术 – 请参见有关使用 `XmlSerializer` 的主题。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-267">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="ec6d2-268">您可能希望重新使用代理中的现有 `IXmlSerializable` 类型，而不生成新的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-268">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="ec6d2-269">在此情况下，“导入架构以生成类型”主题中介绍的引用类型功能可用于指示要重新使用的类型。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-269">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="ec6d2-270">这对应于在 svcutil.exe 上使用 `/reference` 开关，以指定包含要重新使用的类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-270">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="ec6d2-271">XmlSerializer Legacy Behavior</span><span class="sxs-lookup"><span data-stu-id="ec6d2-271">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="ec6d2-272">在 .NET Framework 4.0 和更早版本中，XmlSerializer 通过将 C# 代码写入某一文件，生成临时序列化程序集。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-272">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="ec6d2-273">然后将该文件编译为一个程序集。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-273">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="ec6d2-274">这种行为会产生不想要的结果，例如序列化程序的启动时间延长。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-274">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="ec6d2-275">在 .NET Framework 4.5 中，已对此行为进行了更改，无需使用该编译器即可生成程序集。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-275">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="ec6d2-276">一些开发人员可能希望看到生成的 C# 代码。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-276">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="ec6d2-277">您可以通过以下配置指定为使用这一旧行为：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-277">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="ec6d2-278">如果遇到兼容性问题（例如无法 `XmlSerializer` 使用非公共新替代序列化派生类），则可以 `XMLSerializer` 使用以下配置切换回旧行为：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-278">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="ec6d2-279">作为上述配置的替代方法，你可以在运行 .NET Framework 4.5 或更高版本的计算机上使用以下配置：</span><span class="sxs-lookup"><span data-stu-id="ec6d2-279">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="ec6d2-280">此 `<xmlSerializer useLegacySerializerGeneration="true"/>` 开关仅适用于运行 .NET Framework 4.5 或更高版本的计算机。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-280">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="ec6d2-281">上述 `appSettings` 方法适用于所有 .NET Framework 版本。</span><span class="sxs-lookup"><span data-stu-id="ec6d2-281">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="ec6d2-282">另请参阅</span><span class="sxs-lookup"><span data-stu-id="ec6d2-282">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="ec6d2-283">在服务协定中指定数据传输</span><span class="sxs-lookup"><span data-stu-id="ec6d2-283">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="ec6d2-284">使用数据协定</span><span class="sxs-lookup"><span data-stu-id="ec6d2-284">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="ec6d2-285">如何：使用 XmlSerializer 改善 WCF 客户端应用程序的启动时间</span><span class="sxs-lookup"><span data-stu-id="ec6d2-285">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
