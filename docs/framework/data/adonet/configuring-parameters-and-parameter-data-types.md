---
title: 配置参数和参数数据类型
description: 命令对象使用参数将值传递给 SQL 语句或存储过程，在 ADO.NET 中提供类型检查和验证。
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 537d8a2c-d40b-4000-83eb-bc1fcc93f707
ms.openlocfilehash: a426eeae785274b0484a84a2fae2dce4572fb4c4
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/02/2020
ms.locfileid: "84287111"
---
# <a name="configuring-parameters-and-parameter-data-types"></a><span data-ttu-id="397a7-103">配置参数和参数数据类型</span><span class="sxs-lookup"><span data-stu-id="397a7-103">Configuring parameters and parameter data types</span></span>

<span data-ttu-id="397a7-104">通过提供类型检查和验证，命令对象可使用参数来将值传递给 SQL 语句或存储过程。</span><span class="sxs-lookup"><span data-stu-id="397a7-104">Command objects use parameters to pass values to SQL statements or stored procedures, providing type checking and validation.</span></span> <span data-ttu-id="397a7-105">与命令文本不同，参数输入被视为文本值，而不是可执行代码。</span><span class="sxs-lookup"><span data-stu-id="397a7-105">Unlike command text, parameter input is treated as a literal value, not as executable code.</span></span> <span data-ttu-id="397a7-106">这样可帮助抵御“SQL 注入”攻击，这种攻击的攻击者会将命令插入 SQL 语句，从而危及服务器的安全。</span><span class="sxs-lookup"><span data-stu-id="397a7-106">This helps guard against "SQL injection" attacks, in which an attacker inserts a command that compromises security on the server into an SQL statement.</span></span>

<span data-ttu-id="397a7-107">参数化命令还可提高查询执行性能，因为它们可帮助数据库服务器将传入命令与适当的缓存查询计划进行准确匹配。</span><span class="sxs-lookup"><span data-stu-id="397a7-107">Parameterized commands can also improve query execution performance, because they help the database server accurately match the incoming command with a proper cached query plan.</span></span> <span data-ttu-id="397a7-108">有关详细信息，请参阅[执行计划缓存和重用](/sql/relational-databases/query-processing-architecture-guide#execution-plan-caching-and-reuse)以及[参数和执行计划重用](/sql/relational-databases/query-processing-architecture-guide#PlanReuse)。</span><span class="sxs-lookup"><span data-stu-id="397a7-108">For more information, see [Execution Plan Caching and Reuse](/sql/relational-databases/query-processing-architecture-guide#execution-plan-caching-and-reuse) and [Parameters and Execution Plan Reuse](/sql/relational-databases/query-processing-architecture-guide#PlanReuse).</span></span> <span data-ttu-id="397a7-109">除具备安全和性能优势外，参数化命令还提供一种用于组织传递到数据源的值的便捷方法。</span><span class="sxs-lookup"><span data-stu-id="397a7-109">In addition to the security and performance benefits, parameterized commands provide a convenient method for organizing values passed to a data source.</span></span>

<span data-ttu-id="397a7-110"><xref:System.Data.Common.DbParameter> 对象可以通过使用其构造函数来创建，或者也可以通过调用 <xref:System.Data.Common.DbCommand.DbParameterCollection%2A> 集合的 `Add` 方法以将该对象添加到 <xref:System.Data.Common.DbParameterCollection> 来创建。</span><span class="sxs-lookup"><span data-stu-id="397a7-110">A <xref:System.Data.Common.DbParameter> object can be created by using its constructor, or by adding it to the <xref:System.Data.Common.DbCommand.DbParameterCollection%2A> by calling the `Add` method of the <xref:System.Data.Common.DbParameterCollection> collection.</span></span> <span data-ttu-id="397a7-111">`Add` 方法将构造函数实参或现有形参对象用作输入，具体取决于数据提供程序。</span><span class="sxs-lookup"><span data-stu-id="397a7-111">The `Add` method will take as input either constructor arguments or an existing parameter object, depending on the data provider.</span></span>

## <a name="supplying-the-parameterdirection-property"></a><span data-ttu-id="397a7-112">提供 ParameterDirection 属性</span><span class="sxs-lookup"><span data-stu-id="397a7-112">Supplying the ParameterDirection property</span></span>

<span data-ttu-id="397a7-113">在添加参数时，您必须为输入参数以外的参数提供一个 <xref:System.Data.ParameterDirection> 属性。</span><span class="sxs-lookup"><span data-stu-id="397a7-113">When adding parameters, you must supply a <xref:System.Data.ParameterDirection> property for parameters other than input parameters.</span></span> <span data-ttu-id="397a7-114">下表显示了可用于 `ParameterDirection` 枚举的 <xref:System.Data.ParameterDirection> 值。</span><span class="sxs-lookup"><span data-stu-id="397a7-114">The following table shows the `ParameterDirection` values that you can use with the <xref:System.Data.ParameterDirection> enumeration.</span></span>

|<span data-ttu-id="397a7-115">成员名称</span><span class="sxs-lookup"><span data-stu-id="397a7-115">Member name</span></span>|<span data-ttu-id="397a7-116">说明</span><span class="sxs-lookup"><span data-stu-id="397a7-116">Description</span></span>|
|-----------------|-----------------|
|<xref:System.Data.ParameterDirection.Input>|<span data-ttu-id="397a7-117">该参数为输入参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-117">The parameter is an input parameter.</span></span> <span data-ttu-id="397a7-118">这是默认设置。</span><span class="sxs-lookup"><span data-stu-id="397a7-118">This is the default.</span></span>|
|<xref:System.Data.ParameterDirection.InputOutput>|<span data-ttu-id="397a7-119">该参数可执行输入和输出。</span><span class="sxs-lookup"><span data-stu-id="397a7-119">The parameter can perform both input and output.</span></span>|
|<xref:System.Data.ParameterDirection.Output>|<span data-ttu-id="397a7-120">该参数为输出参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-120">The parameter is an output parameter.</span></span>|
|<xref:System.Data.ParameterDirection.ReturnValue>|<span data-ttu-id="397a7-121">该参数表示从某操作（如存储过程、内置函数或用户定义的函数）返回的值。</span><span class="sxs-lookup"><span data-stu-id="397a7-121">The parameter represents a return value from an operation such as a stored procedure, built-in function, or user-defined function.</span></span>|

## <a name="working-with-parameter-placeholders"></a><span data-ttu-id="397a7-122">使用参数占位符</span><span class="sxs-lookup"><span data-stu-id="397a7-122">Working with parameter placeholders</span></span>

<span data-ttu-id="397a7-123">参数占位符的语法取决于数据源。</span><span class="sxs-lookup"><span data-stu-id="397a7-123">The syntax for parameter placeholders depends on the data source.</span></span> <span data-ttu-id="397a7-124">.NET Framework 数据提供程序以不同方式处理命名和指定参数和参数占位符。</span><span class="sxs-lookup"><span data-stu-id="397a7-124">The .NET Framework data providers handle naming and specifying parameters and parameter placeholders differently.</span></span> <span data-ttu-id="397a7-125">此语法是针对某个特定的数据源自定义的，如下表所述。</span><span class="sxs-lookup"><span data-stu-id="397a7-125">This syntax is customized to a specific data source, as described in the following table.</span></span>

|<span data-ttu-id="397a7-126">数据提供程序</span><span class="sxs-lookup"><span data-stu-id="397a7-126">Data provider</span></span>|<span data-ttu-id="397a7-127">参数命名语法</span><span class="sxs-lookup"><span data-stu-id="397a7-127">Parameter naming syntax</span></span>|
|-------------------|-----------------------------|
|<xref:System.Data.SqlClient>|<span data-ttu-id="397a7-128">以 `@`*参数名*格式使用命名参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-128">Uses named parameters in the format `@`*parametername*.</span></span>|
|<xref:System.Data.OleDb>|<span data-ttu-id="397a7-129">使用由问号 (`?`) 指示的位置参数标记。</span><span class="sxs-lookup"><span data-stu-id="397a7-129">Uses positional parameter markers indicated by a question mark (`?`).</span></span>|
|<xref:System.Data.Odbc>|<span data-ttu-id="397a7-130">使用由问号 (`?`) 指示的位置参数标记。</span><span class="sxs-lookup"><span data-stu-id="397a7-130">Uses positional parameter markers indicated by a question mark (`?`).</span></span>|
|<xref:System.Data.OracleClient>|<span data-ttu-id="397a7-131">以 `:`*参数名* （或 *参数名*）格式使用命名参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-131">Uses named parameters in the format `:`*parmname* (or *parmname*).</span></span>|

## <a name="specifying-parameter-data-types"></a><span data-ttu-id="397a7-132">指定参数数据类型</span><span class="sxs-lookup"><span data-stu-id="397a7-132">Specifying parameter data types</span></span>

<span data-ttu-id="397a7-133">参数的数据类型特定于 .NET Framework 的数据访问接口。</span><span class="sxs-lookup"><span data-stu-id="397a7-133">The data type of a parameter is specific to the .NET Framework data provider.</span></span> <span data-ttu-id="397a7-134">在将值传递给数据源之前，指定类型将的值转换 `Parameter` 为 .NET Framework 数据提供程序类型。</span><span class="sxs-lookup"><span data-stu-id="397a7-134">Specifying the type converts the value of the `Parameter` to the .NET Framework data provider type before passing the value to the data source.</span></span> <span data-ttu-id="397a7-135">也可以通过通用的方式指定 `Parameter` 的类型，方法是将 `DbType` 对象的 `Parameter` 属性设置为特定的 <xref:System.Data.DbType>。</span><span class="sxs-lookup"><span data-stu-id="397a7-135">You may also specify the type of a `Parameter` in a generic manner by setting the `DbType` property of the `Parameter` object to a particular <xref:System.Data.DbType>.</span></span>

<span data-ttu-id="397a7-136">对象的 .NET Framework 数据提供程序类型 `Parameter` 是从对象的的 .NET Framework 类型 `Value` `Parameter` 或从对象的来推断的 `DbType` `Parameter` 。</span><span class="sxs-lookup"><span data-stu-id="397a7-136">The .NET Framework data provider type of a `Parameter` object is inferred from the .NET Framework type of the `Value` of the `Parameter` object, or from the `DbType` of the `Parameter` object.</span></span> <span data-ttu-id="397a7-137">下表显示了根据作为 `Parameter` 值传递的对象或指定的 `Parameter` 推断出的 `DbType`类型。</span><span class="sxs-lookup"><span data-stu-id="397a7-137">The following table shows the inferred `Parameter` type based on the object passed as the `Parameter` value or the specified `DbType`.</span></span>

|<span data-ttu-id="397a7-138">.NET Framework 类型</span><span class="sxs-lookup"><span data-stu-id="397a7-138">.NET Framework type</span></span>|<span data-ttu-id="397a7-139">DbType</span><span class="sxs-lookup"><span data-stu-id="397a7-139">DbType</span></span>|<span data-ttu-id="397a7-140">SqlDbType</span><span class="sxs-lookup"><span data-stu-id="397a7-140">SqlDbType</span></span>|<span data-ttu-id="397a7-141">OleDbType</span><span class="sxs-lookup"><span data-stu-id="397a7-141">OleDbType</span></span>|<span data-ttu-id="397a7-142">OdbcType</span><span class="sxs-lookup"><span data-stu-id="397a7-142">OdbcType</span></span>|<span data-ttu-id="397a7-143">OracleType</span><span class="sxs-lookup"><span data-stu-id="397a7-143">OracleType</span></span>|
|-------------------------|------------|---------------|---------------|--------------|----------------|
|<xref:System.Boolean>|<span data-ttu-id="397a7-144">Boolean</span><span class="sxs-lookup"><span data-stu-id="397a7-144">Boolean</span></span>|<span data-ttu-id="397a7-145">bit</span><span class="sxs-lookup"><span data-stu-id="397a7-145">Bit</span></span>|<span data-ttu-id="397a7-146">Boolean</span><span class="sxs-lookup"><span data-stu-id="397a7-146">Boolean</span></span>|<span data-ttu-id="397a7-147">bit</span><span class="sxs-lookup"><span data-stu-id="397a7-147">Bit</span></span>|<span data-ttu-id="397a7-148">Byte</span><span class="sxs-lookup"><span data-stu-id="397a7-148">Byte</span></span>|
|<xref:System.Byte>|<span data-ttu-id="397a7-149">Byte</span><span class="sxs-lookup"><span data-stu-id="397a7-149">Byte</span></span>|<span data-ttu-id="397a7-150">TinyInt</span><span class="sxs-lookup"><span data-stu-id="397a7-150">TinyInt</span></span>|<span data-ttu-id="397a7-151">UnsignedTinyInt</span><span class="sxs-lookup"><span data-stu-id="397a7-151">UnsignedTinyInt</span></span>|<span data-ttu-id="397a7-152">TinyInt</span><span class="sxs-lookup"><span data-stu-id="397a7-152">TinyInt</span></span>|<span data-ttu-id="397a7-153">Byte</span><span class="sxs-lookup"><span data-stu-id="397a7-153">Byte</span></span>|
|<span data-ttu-id="397a7-154">byte[]</span><span class="sxs-lookup"><span data-stu-id="397a7-154">byte[]</span></span>|<span data-ttu-id="397a7-155">二进制</span><span class="sxs-lookup"><span data-stu-id="397a7-155">Binary</span></span>|<span data-ttu-id="397a7-156">VarBinary.</span><span class="sxs-lookup"><span data-stu-id="397a7-156">VarBinary.</span></span> <span data-ttu-id="397a7-157">如果字节数组大于 VarBinary 的最大大小（8000字节），此隐式转换将失败。对于大于8000字节的字节数组，请显式设置 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-157">This implicit conversion will fail if the byte array is larger than the maximum size of a VarBinary, which is 8000 bytes.For byte arrays larger than 8000 bytes, explicitly set the <xref:System.Data.SqlDbType>.</span></span>|<span data-ttu-id="397a7-158">VarBinary</span><span class="sxs-lookup"><span data-stu-id="397a7-158">VarBinary</span></span>|<span data-ttu-id="397a7-159">二进制</span><span class="sxs-lookup"><span data-stu-id="397a7-159">Binary</span></span>|<span data-ttu-id="397a7-160">原始</span><span class="sxs-lookup"><span data-stu-id="397a7-160">Raw</span></span>|
|<xref:System.Char>| |<span data-ttu-id="397a7-161">不支持从 char 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-161">Inferring a <xref:System.Data.SqlDbType> from char is not supported.</span></span>|<span data-ttu-id="397a7-162">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-162">Char</span></span>|<span data-ttu-id="397a7-163">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-163">Char</span></span>|<span data-ttu-id="397a7-164">Byte</span><span class="sxs-lookup"><span data-stu-id="397a7-164">Byte</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="397a7-165">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-165">DateTime</span></span>|<span data-ttu-id="397a7-166">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-166">DateTime</span></span>|<span data-ttu-id="397a7-167">DBTimeStamp</span><span class="sxs-lookup"><span data-stu-id="397a7-167">DBTimeStamp</span></span>|<span data-ttu-id="397a7-168">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-168">DateTime</span></span>|<span data-ttu-id="397a7-169">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-169">DateTime</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="397a7-170">DateTimeOffset</span><span class="sxs-lookup"><span data-stu-id="397a7-170">DateTimeOffset</span></span>|<span data-ttu-id="397a7-171">SQL Server 2008 中的 DateTimeOffset。</span><span class="sxs-lookup"><span data-stu-id="397a7-171">DateTimeOffset in SQL Server 2008.</span></span> <span data-ttu-id="397a7-172">SQL Server 2008 以前的 SQL Server 版本不支持从 DateTimeOffset 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-172">Inferring a <xref:System.Data.SqlDbType> from DateTimeOffset is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|||<span data-ttu-id="397a7-173">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-173">DateTime</span></span>|
|<xref:System.Decimal>|<span data-ttu-id="397a7-174">小数</span><span class="sxs-lookup"><span data-stu-id="397a7-174">Decimal</span></span>|<span data-ttu-id="397a7-175">小数</span><span class="sxs-lookup"><span data-stu-id="397a7-175">Decimal</span></span>|<span data-ttu-id="397a7-176">小数</span><span class="sxs-lookup"><span data-stu-id="397a7-176">Decimal</span></span>|<span data-ttu-id="397a7-177">Numeric</span><span class="sxs-lookup"><span data-stu-id="397a7-177">Numeric</span></span>|<span data-ttu-id="397a7-178">Number</span><span class="sxs-lookup"><span data-stu-id="397a7-178">Number</span></span>|
|<xref:System.Double>|<span data-ttu-id="397a7-179">Double</span><span class="sxs-lookup"><span data-stu-id="397a7-179">Double</span></span>|<span data-ttu-id="397a7-180">Float</span><span class="sxs-lookup"><span data-stu-id="397a7-180">Float</span></span>|<span data-ttu-id="397a7-181">Double</span><span class="sxs-lookup"><span data-stu-id="397a7-181">Double</span></span>|<span data-ttu-id="397a7-182">Double</span><span class="sxs-lookup"><span data-stu-id="397a7-182">Double</span></span>|<span data-ttu-id="397a7-183">Double</span><span class="sxs-lookup"><span data-stu-id="397a7-183">Double</span></span>|
|<xref:System.Single>|<span data-ttu-id="397a7-184">Single</span><span class="sxs-lookup"><span data-stu-id="397a7-184">Single</span></span>|<span data-ttu-id="397a7-185">Real</span><span class="sxs-lookup"><span data-stu-id="397a7-185">Real</span></span>|<span data-ttu-id="397a7-186">Single</span><span class="sxs-lookup"><span data-stu-id="397a7-186">Single</span></span>|<span data-ttu-id="397a7-187">Real</span><span class="sxs-lookup"><span data-stu-id="397a7-187">Real</span></span>|<span data-ttu-id="397a7-188">Float</span><span class="sxs-lookup"><span data-stu-id="397a7-188">Float</span></span>|
|<xref:System.Guid>|<span data-ttu-id="397a7-189">Guid</span><span class="sxs-lookup"><span data-stu-id="397a7-189">Guid</span></span>|<span data-ttu-id="397a7-190">UniqueIdentifier</span><span class="sxs-lookup"><span data-stu-id="397a7-190">UniqueIdentifier</span></span>|<span data-ttu-id="397a7-191">Guid</span><span class="sxs-lookup"><span data-stu-id="397a7-191">Guid</span></span>|<span data-ttu-id="397a7-192">UniqueIdentifier</span><span class="sxs-lookup"><span data-stu-id="397a7-192">UniqueIdentifier</span></span>|<span data-ttu-id="397a7-193">原始</span><span class="sxs-lookup"><span data-stu-id="397a7-193">Raw</span></span>|
|<xref:System.Int16>|<span data-ttu-id="397a7-194">Int16</span><span class="sxs-lookup"><span data-stu-id="397a7-194">Int16</span></span>|<span data-ttu-id="397a7-195">SmallInt</span><span class="sxs-lookup"><span data-stu-id="397a7-195">SmallInt</span></span>|<span data-ttu-id="397a7-196">SmallInt</span><span class="sxs-lookup"><span data-stu-id="397a7-196">SmallInt</span></span>|<span data-ttu-id="397a7-197">SmallInt</span><span class="sxs-lookup"><span data-stu-id="397a7-197">SmallInt</span></span>|<span data-ttu-id="397a7-198">Int16</span><span class="sxs-lookup"><span data-stu-id="397a7-198">Int16</span></span>|
|<xref:System.Int32>|<span data-ttu-id="397a7-199">Int32</span><span class="sxs-lookup"><span data-stu-id="397a7-199">Int32</span></span>|<span data-ttu-id="397a7-200">int</span><span class="sxs-lookup"><span data-stu-id="397a7-200">Int</span></span>|<span data-ttu-id="397a7-201">int</span><span class="sxs-lookup"><span data-stu-id="397a7-201">Int</span></span>|<span data-ttu-id="397a7-202">int</span><span class="sxs-lookup"><span data-stu-id="397a7-202">Int</span></span>|<span data-ttu-id="397a7-203">Int32</span><span class="sxs-lookup"><span data-stu-id="397a7-203">Int32</span></span>|
|<xref:System.Int64>|<span data-ttu-id="397a7-204">Int64</span><span class="sxs-lookup"><span data-stu-id="397a7-204">Int64</span></span>|<span data-ttu-id="397a7-205">BigInt</span><span class="sxs-lookup"><span data-stu-id="397a7-205">BigInt</span></span>|<span data-ttu-id="397a7-206">BigInt</span><span class="sxs-lookup"><span data-stu-id="397a7-206">BigInt</span></span>|<span data-ttu-id="397a7-207">BigInt</span><span class="sxs-lookup"><span data-stu-id="397a7-207">BigInt</span></span>|<span data-ttu-id="397a7-208">Number</span><span class="sxs-lookup"><span data-stu-id="397a7-208">Number</span></span>|
|<xref:System.Object>|<span data-ttu-id="397a7-209">对象</span><span class="sxs-lookup"><span data-stu-id="397a7-209">Object</span></span>|<span data-ttu-id="397a7-210">变量</span><span class="sxs-lookup"><span data-stu-id="397a7-210">Variant</span></span>|<span data-ttu-id="397a7-211">变量</span><span class="sxs-lookup"><span data-stu-id="397a7-211">Variant</span></span>|<span data-ttu-id="397a7-212">不支持从 Object 推断 OdbcType。</span><span class="sxs-lookup"><span data-stu-id="397a7-212">Inferring an OdbcType from Object is not supported.</span></span>|<span data-ttu-id="397a7-213">Blob</span><span class="sxs-lookup"><span data-stu-id="397a7-213">Blob</span></span>|
|<xref:System.String>|<span data-ttu-id="397a7-214">String</span><span class="sxs-lookup"><span data-stu-id="397a7-214">String</span></span>|<span data-ttu-id="397a7-215">NVarChar。</span><span class="sxs-lookup"><span data-stu-id="397a7-215">NVarChar.</span></span> <span data-ttu-id="397a7-216">如果字符串大于 NVarChar 的最大大小（4000 个字符），此隐式转换将失败。</span><span class="sxs-lookup"><span data-stu-id="397a7-216">This implicit conversion will fail if the string is larger than the maximum size of an NVarChar, which is 4000 characters.</span></span> <span data-ttu-id="397a7-217">对于大于 4000 个字符的字符串，请显式设置 <xref:System.Data.SqlDbType>。</span><span class="sxs-lookup"><span data-stu-id="397a7-217">For strings larger than 4000 characters, explicitly set the <xref:System.Data.SqlDbType>.</span></span>|<span data-ttu-id="397a7-218">VarWChar</span><span class="sxs-lookup"><span data-stu-id="397a7-218">VarWChar</span></span>|<span data-ttu-id="397a7-219">NVarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-219">NVarChar</span></span>|<span data-ttu-id="397a7-220">NVarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-220">NVarChar</span></span>|
|<xref:System.TimeSpan>|<span data-ttu-id="397a7-221">时间</span><span class="sxs-lookup"><span data-stu-id="397a7-221">Time</span></span>|<span data-ttu-id="397a7-222">SQL Server 2008 中的 Time。</span><span class="sxs-lookup"><span data-stu-id="397a7-222">Time in SQL Server 2008.</span></span> <span data-ttu-id="397a7-223">SQL Server 2008 以前的 SQL Server 版本不支持从 TimeSpan 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-223">Inferring a <xref:System.Data.SqlDbType> from TimeSpan is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="397a7-224">DBTime</span><span class="sxs-lookup"><span data-stu-id="397a7-224">DBTime</span></span>|<span data-ttu-id="397a7-225">时间</span><span class="sxs-lookup"><span data-stu-id="397a7-225">Time</span></span>|<span data-ttu-id="397a7-226">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-226">DateTime</span></span>|
|<xref:System.UInt16>|<span data-ttu-id="397a7-227">UInt16</span><span class="sxs-lookup"><span data-stu-id="397a7-227">UInt16</span></span>|<span data-ttu-id="397a7-228">不支持从 UInt16 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-228">Inferring a <xref:System.Data.SqlDbType> from UInt16 is not supported.</span></span>|<span data-ttu-id="397a7-229">UnsignedSmallInt</span><span class="sxs-lookup"><span data-stu-id="397a7-229">UnsignedSmallInt</span></span>|<span data-ttu-id="397a7-230">int</span><span class="sxs-lookup"><span data-stu-id="397a7-230">Int</span></span>|<span data-ttu-id="397a7-231">UInt16</span><span class="sxs-lookup"><span data-stu-id="397a7-231">UInt16</span></span>|
|<xref:System.UInt32>|<span data-ttu-id="397a7-232">UInt32</span><span class="sxs-lookup"><span data-stu-id="397a7-232">UInt32</span></span>|<span data-ttu-id="397a7-233">不支持从 UInt32 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-233">Inferring a <xref:System.Data.SqlDbType> from UInt32 is not supported.</span></span>|<span data-ttu-id="397a7-234">UnsignedInt</span><span class="sxs-lookup"><span data-stu-id="397a7-234">UnsignedInt</span></span>|<span data-ttu-id="397a7-235">BigInt</span><span class="sxs-lookup"><span data-stu-id="397a7-235">BigInt</span></span>|<span data-ttu-id="397a7-236">UInt32</span><span class="sxs-lookup"><span data-stu-id="397a7-236">UInt32</span></span>|
|<xref:System.UInt64>|<span data-ttu-id="397a7-237">UInt64</span><span class="sxs-lookup"><span data-stu-id="397a7-237">UInt64</span></span>|<span data-ttu-id="397a7-238">不支持从 UInt64 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-238">Inferring a <xref:System.Data.SqlDbType> from UInt64 is not supported.</span></span>|<span data-ttu-id="397a7-239">UnsignedBigInt</span><span class="sxs-lookup"><span data-stu-id="397a7-239">UnsignedBigInt</span></span>|<span data-ttu-id="397a7-240">数字</span><span class="sxs-lookup"><span data-stu-id="397a7-240">Numeric</span></span>|<span data-ttu-id="397a7-241">Number</span><span class="sxs-lookup"><span data-stu-id="397a7-241">Number</span></span>|
||<span data-ttu-id="397a7-242">AnsiString</span><span class="sxs-lookup"><span data-stu-id="397a7-242">AnsiString</span></span>|<span data-ttu-id="397a7-243">VarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-243">VarChar</span></span>|<span data-ttu-id="397a7-244">VarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-244">VarChar</span></span>|<span data-ttu-id="397a7-245">VarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-245">VarChar</span></span>|<span data-ttu-id="397a7-246">VarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-246">VarChar</span></span>|
||<span data-ttu-id="397a7-247">AnsiStringFixedLength</span><span class="sxs-lookup"><span data-stu-id="397a7-247">AnsiStringFixedLength</span></span>|<span data-ttu-id="397a7-248">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-248">Char</span></span>|<span data-ttu-id="397a7-249">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-249">Char</span></span>|<span data-ttu-id="397a7-250">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-250">Char</span></span>|<span data-ttu-id="397a7-251">Char</span><span class="sxs-lookup"><span data-stu-id="397a7-251">Char</span></span>|
||<span data-ttu-id="397a7-252">货币</span><span class="sxs-lookup"><span data-stu-id="397a7-252">Currency</span></span>|<span data-ttu-id="397a7-253">Money</span><span class="sxs-lookup"><span data-stu-id="397a7-253">Money</span></span>|<span data-ttu-id="397a7-254">货币</span><span class="sxs-lookup"><span data-stu-id="397a7-254">Currency</span></span>|<span data-ttu-id="397a7-255">不支持从 `OdbcType` 推断 `Currency` 。</span><span class="sxs-lookup"><span data-stu-id="397a7-255">Inferring an `OdbcType` from `Currency` is not supported.</span></span>|<span data-ttu-id="397a7-256">Number</span><span class="sxs-lookup"><span data-stu-id="397a7-256">Number</span></span>|
||<span data-ttu-id="397a7-257">日期</span><span class="sxs-lookup"><span data-stu-id="397a7-257">Date</span></span>|<span data-ttu-id="397a7-258">SQL Server 2008 中的 Date。</span><span class="sxs-lookup"><span data-stu-id="397a7-258">Date in SQL Server 2008.</span></span> <span data-ttu-id="397a7-259">SQL Server 2008 以前的 SQL Server 版本不支持从 Date 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-259">Inferring a <xref:System.Data.SqlDbType> from Date is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="397a7-260">DBDate</span><span class="sxs-lookup"><span data-stu-id="397a7-260">DBDate</span></span>|<span data-ttu-id="397a7-261">Date</span><span class="sxs-lookup"><span data-stu-id="397a7-261">Date</span></span>|<span data-ttu-id="397a7-262">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-262">DateTime</span></span>|
||<span data-ttu-id="397a7-263">SByte</span><span class="sxs-lookup"><span data-stu-id="397a7-263">SByte</span></span>|<span data-ttu-id="397a7-264">不支持从 SByte 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-264">Inferring a <xref:System.Data.SqlDbType> from SByte is not supported.</span></span>|<span data-ttu-id="397a7-265">TinyInt</span><span class="sxs-lookup"><span data-stu-id="397a7-265">TinyInt</span></span>|<span data-ttu-id="397a7-266">不支持从 SByte 推断 `OdbcType` 。</span><span class="sxs-lookup"><span data-stu-id="397a7-266">Inferring an `OdbcType` from SByte is not supported.</span></span>|<span data-ttu-id="397a7-267">SByte</span><span class="sxs-lookup"><span data-stu-id="397a7-267">SByte</span></span>|
||<span data-ttu-id="397a7-268">StringFixedLength</span><span class="sxs-lookup"><span data-stu-id="397a7-268">StringFixedLength</span></span>|<span data-ttu-id="397a7-269">NChar</span><span class="sxs-lookup"><span data-stu-id="397a7-269">NChar</span></span>|<span data-ttu-id="397a7-270">WChar</span><span class="sxs-lookup"><span data-stu-id="397a7-270">WChar</span></span>|<span data-ttu-id="397a7-271">NChar</span><span class="sxs-lookup"><span data-stu-id="397a7-271">NChar</span></span>|<span data-ttu-id="397a7-272">NChar</span><span class="sxs-lookup"><span data-stu-id="397a7-272">NChar</span></span>|
||<span data-ttu-id="397a7-273">时间</span><span class="sxs-lookup"><span data-stu-id="397a7-273">Time</span></span>|<span data-ttu-id="397a7-274">SQL Server 2008 中的 Time。</span><span class="sxs-lookup"><span data-stu-id="397a7-274">Time in SQL Server 2008.</span></span> <span data-ttu-id="397a7-275">SQL Server 2008 以前的 SQL Server 版本不支持从 Time 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-275">Inferring a <xref:System.Data.SqlDbType> from Time is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="397a7-276">DBTime</span><span class="sxs-lookup"><span data-stu-id="397a7-276">DBTime</span></span>|<span data-ttu-id="397a7-277">时间</span><span class="sxs-lookup"><span data-stu-id="397a7-277">Time</span></span>|<span data-ttu-id="397a7-278">DateTime</span><span class="sxs-lookup"><span data-stu-id="397a7-278">DateTime</span></span>|
||<span data-ttu-id="397a7-279">VarNumeric</span><span class="sxs-lookup"><span data-stu-id="397a7-279">VarNumeric</span></span>|<span data-ttu-id="397a7-280">不支持从 VarNumeric 推断 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-280">Inferring a <xref:System.Data.SqlDbType> from VarNumeric is not supported.</span></span>|<span data-ttu-id="397a7-281">VarNumeric</span><span class="sxs-lookup"><span data-stu-id="397a7-281">VarNumeric</span></span>|<span data-ttu-id="397a7-282">不支持从 VarNumeric 推断 `OdbcType` 。</span><span class="sxs-lookup"><span data-stu-id="397a7-282">Inferring an `OdbcType` from VarNumeric is not supported.</span></span>|<span data-ttu-id="397a7-283">Number</span><span class="sxs-lookup"><span data-stu-id="397a7-283">Number</span></span>|
|<span data-ttu-id="397a7-284">用户定义类型（带有 <xref:Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute>的对象）</span><span class="sxs-lookup"><span data-stu-id="397a7-284">user-defined type (an object with <xref:Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute></span></span>|<span data-ttu-id="397a7-285">对象或字符串，具体取决于提供程序（SqlClient 始终返回对象，Odbc 始终返回字符串，而 OleDb 托管数据提供程序可查看两者中的任何一个</span><span class="sxs-lookup"><span data-stu-id="397a7-285">Object or String, depending the provider (SqlClient always returns an Object, Odbc always returns a String, and the OleDb managed data provider can see either</span></span>|<span data-ttu-id="397a7-286">如果存在 <xref:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute> ，则为 SqlDbType.Udt；否则为 Variant</span><span class="sxs-lookup"><span data-stu-id="397a7-286">SqlDbType.Udt if <xref:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute> is present, otherwise Variant</span></span>|<span data-ttu-id="397a7-287">OleDbType.VarWChar（如果值为 null），否则为 OleDbType.Variant。</span><span class="sxs-lookup"><span data-stu-id="397a7-287">OleDbType.VarWChar (if value is null) otherwise OleDbType.Variant.</span></span>|<span data-ttu-id="397a7-288">OdbcType.NVarChar</span><span class="sxs-lookup"><span data-stu-id="397a7-288">OdbcType.NVarChar</span></span>|<span data-ttu-id="397a7-289">不受支持</span><span class="sxs-lookup"><span data-stu-id="397a7-289">not supported</span></span>|

> [!NOTE]
> <span data-ttu-id="397a7-290">从小数转换到其他类型是缩窄转换，这种转换会将小数值舍入到最近的接近零的整数值。</span><span class="sxs-lookup"><span data-stu-id="397a7-290">Conversions from decimal to other types are narrowing conversions that round the decimal value to the nearest integer value toward zero.</span></span> <span data-ttu-id="397a7-291">如果无法以目标类型表示转换结果，则会引发 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="397a7-291">If the result of the conversion is not representable in the destination type, an <xref:System.OverflowException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="397a7-292">将 null 参数值发送到服务器时，必须指定 <xref:System.DBNull> ，而不是 `null` （ `Nothing` 在 Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="397a7-292">When you send a null parameter value to the server, you must specify <xref:System.DBNull>, not `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="397a7-293">系统中的 NULL 值是没有值的空对象。</span><span class="sxs-lookup"><span data-stu-id="397a7-293">The null value in the system is an empty object that has no value.</span></span> <span data-ttu-id="397a7-294"><xref:System.DBNull> 用于表示 NULL 值。</span><span class="sxs-lookup"><span data-stu-id="397a7-294"><xref:System.DBNull> is used to represent null values.</span></span> <span data-ttu-id="397a7-295">有关数据库 null 值的详细信息，请参阅[处理 Null 值](./sql/handling-null-values.md)。</span><span class="sxs-lookup"><span data-stu-id="397a7-295">For more information about database nulls, see [Handling Null Values](./sql/handling-null-values.md).</span></span>

## <a name="deriving-parameter-information"></a><span data-ttu-id="397a7-296">派生参数信息</span><span class="sxs-lookup"><span data-stu-id="397a7-296">Deriving parameter information</span></span>

<span data-ttu-id="397a7-297">还可以使用 `DbCommandBuilder` 类从存储过程派生参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-297">Parameters can also be derived from a stored procedure using the `DbCommandBuilder` class.</span></span> <span data-ttu-id="397a7-298">`SqlCommandBuilder` 和 `OleDbCommandBuilder` 类都提供了静态方法 `DeriveParameters`，该静态方法将自动使用存储过程中的参数信息填充 Command 对象的 Parameters 集合。</span><span class="sxs-lookup"><span data-stu-id="397a7-298">Both the `SqlCommandBuilder` and `OleDbCommandBuilder` classes provide a static method, `DeriveParameters`, which automatically populates the parameters collection of a command object that uses parameter information from a stored procedure.</span></span> <span data-ttu-id="397a7-299">请注意， `DeriveParameters` 会覆盖此命令的任何现有参数信息。</span><span class="sxs-lookup"><span data-stu-id="397a7-299">Note that `DeriveParameters` overwrites any existing parameter information for the command.</span></span>

> [!NOTE]
> <span data-ttu-id="397a7-300">派生参数信息会影响性能，因为它需要对数据源进行额外的往返访问，以检索信息。</span><span class="sxs-lookup"><span data-stu-id="397a7-300">Deriving parameter information incurs a performance penalty because it requires an additional round trip to the data source to retrieve the information.</span></span> <span data-ttu-id="397a7-301">如果参数信息在设计时是已知的，则可以通过显式设置参数来提高应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="397a7-301">If parameter information is known at design time, you can improve the performance of your application by setting the parameters explicitly.</span></span>

<span data-ttu-id="397a7-302">有关详细信息，请参阅[通过 Commandbuilder 生成命令](generating-commands-with-commandbuilders.md)。</span><span class="sxs-lookup"><span data-stu-id="397a7-302">For more information, see [Generating Commands with CommandBuilders](generating-commands-with-commandbuilders.md).</span></span>

## <a name="using-parameters-with-a-sqlcommand-and-a-stored-procedure"></a><span data-ttu-id="397a7-303">对 SqlCommand 和存储过程使用参数</span><span class="sxs-lookup"><span data-stu-id="397a7-303">Using parameters with a SqlCommand and a stored procedure</span></span>

<span data-ttu-id="397a7-304">在数据驱动的应用程序中，存储过程具有许多优势。</span><span class="sxs-lookup"><span data-stu-id="397a7-304">Stored procedures offer many advantages in data-driven applications.</span></span> <span data-ttu-id="397a7-305">通过利用存储过程，数据库操作可以包装在单个命令中，为获取最佳性能而进行优化并通过附加的安全性得到增强。</span><span class="sxs-lookup"><span data-stu-id="397a7-305">By using stored procedures, database operations can be encapsulated in a single command, optimized for best performance, and enhanced with additional security.</span></span> <span data-ttu-id="397a7-306">尽管可以通过将后跟参数参数的存储过程名称作为 SQL 语句传递来调用存储过程，但通过使用 <xref:System.Data.Common.DbCommand.Parameters%2A> ADO.NET 对象的集合， <xref:System.Data.Common.DbCommand> 您可以更明确地定义存储过程参数，并访问输出参数和返回值。</span><span class="sxs-lookup"><span data-stu-id="397a7-306">Although a stored procedure can be called by passing the stored procedure name followed by parameter arguments as an SQL statement, by using the <xref:System.Data.Common.DbCommand.Parameters%2A> collection of the ADO.NET <xref:System.Data.Common.DbCommand> object enables you to more explicitly define stored procedure parameters, and to access output parameters and return values.</span></span>

> [!NOTE]
> <span data-ttu-id="397a7-307">参数化语句在服务器上通过使用 `sp_executesql,` 执行，sp_executesql 允许重复使用查询计划。</span><span class="sxs-lookup"><span data-stu-id="397a7-307">Parameterized statements are executed on the server by using `sp_executesql,` which allows for query plan reuse.</span></span> <span data-ttu-id="397a7-308">`sp_executesql` 批处理命令中的本地光标或变量对于调用 `sp_executesql`的批处理命令是不可见的。</span><span class="sxs-lookup"><span data-stu-id="397a7-308">Local cursors or variables in the `sp_executesql` batch are not visible to the batch that calls `sp_executesql`.</span></span> <span data-ttu-id="397a7-309">数据库上下文中的更改只持续到 `sp_executesql` 语句的结尾。</span><span class="sxs-lookup"><span data-stu-id="397a7-309">Changes in database context last only to the end of the `sp_executesql` statement.</span></span> <span data-ttu-id="397a7-310">有关详细信息，请参阅[sp_executesql （transact-sql）](/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="397a7-310">For more information, see [sp_executesql (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql).</span></span>

<span data-ttu-id="397a7-311">对 <xref:System.Data.SqlClient.SqlCommand> 使用参数以执行 SQL Server 存储过程时，添加到 <xref:System.Data.SqlClient.SqlCommand.Parameters%2A> 集合中的参数的名称必须与存储过程中参数标记的名称相匹配。</span><span class="sxs-lookup"><span data-stu-id="397a7-311">When using parameters with a <xref:System.Data.SqlClient.SqlCommand> to execute a SQL Server stored procedure, the names of the parameters added to the <xref:System.Data.SqlClient.SqlCommand.Parameters%2A> collection must match the names of the parameter markers in the stored procedure.</span></span> <span data-ttu-id="397a7-312">SQL Server 的 .NET Framework 数据提供程序不支持用于向 SQL 语句或存储过程传递参数的问号（？）占位符。</span><span class="sxs-lookup"><span data-stu-id="397a7-312">The .NET Framework Data Provider for SQL Server does not support the question mark (?) placeholder for passing parameters to an SQL statement or a stored procedure.</span></span> <span data-ttu-id="397a7-313">它将存储过程中的参数视为命名参数，并搜索匹配的参数标记。</span><span class="sxs-lookup"><span data-stu-id="397a7-313">It treats parameters in the stored procedure as named parameters and searches for matching parameter markers.</span></span> <span data-ttu-id="397a7-314">例如，通过使用名为 `CustOrderHist` 的参数定义 `@CustomerID`存储过程。</span><span class="sxs-lookup"><span data-stu-id="397a7-314">For example, the `CustOrderHist` stored procedure is defined by using a parameter named `@CustomerID`.</span></span> <span data-ttu-id="397a7-315">您的代码在执行该存储过程时，它也必须使用名为 `@CustomerID`的参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-315">When your code executes the stored procedure, it must also use a parameter named `@CustomerID`.</span></span>

```sql
CREATE PROCEDURE dbo.CustOrderHist @CustomerID varchar(5)
```

### <a name="example"></a><span data-ttu-id="397a7-316">示例</span><span class="sxs-lookup"><span data-stu-id="397a7-316">Example</span></span>

<span data-ttu-id="397a7-317">此示例演示了如何调用 `Northwind` 示例数据库中的 SQL Server 存储过程。</span><span class="sxs-lookup"><span data-stu-id="397a7-317">This example demonstrates how to call a SQL Server stored procedure in the `Northwind` sample database.</span></span> <span data-ttu-id="397a7-318">存储过程的名称为 `dbo.SalesByCategory` ，它具有名为 `@CategoryName` 的输入参数，其数据类型为 `nvarchar(15)`。</span><span class="sxs-lookup"><span data-stu-id="397a7-318">The name of the stored procedure is `dbo.SalesByCategory` and it has an input parameter named `@CategoryName` with a data type of `nvarchar(15)`.</span></span> <span data-ttu-id="397a7-319">该代码在 using 代码块内创建一个新 <xref:System.Data.SqlClient.SqlConnection> ，以便在过程结束时释放连接。</span><span class="sxs-lookup"><span data-stu-id="397a7-319">The code creates a new <xref:System.Data.SqlClient.SqlConnection> inside a using block so that the connection is disposed when the procedure ends.</span></span> <span data-ttu-id="397a7-320">会创建 <xref:System.Data.SqlClient.SqlCommand> 和 <xref:System.Data.SqlClient.SqlParameter> 对象，并设置其属性。</span><span class="sxs-lookup"><span data-stu-id="397a7-320">The <xref:System.Data.SqlClient.SqlCommand> and <xref:System.Data.SqlClient.SqlParameter> objects are created, and their properties set.</span></span> <span data-ttu-id="397a7-321"><xref:System.Data.SqlClient.SqlDataReader> 会执行 `SqlCommand` 并从存储过程返回结果集，以在控制台窗口中显示相关输出。</span><span class="sxs-lookup"><span data-stu-id="397a7-321">A <xref:System.Data.SqlClient.SqlDataReader> executes the `SqlCommand` and returns the result set from the stored procedure, displaying the output in the console window.</span></span>

> [!NOTE]
> <span data-ttu-id="397a7-322">您可以选择使用任一重载构造函数在一个语句中设置多个属性，而不是创建 `SqlCommand` 和 `SqlParameter` 对象，然后在各个语句中设置属性。</span><span class="sxs-lookup"><span data-stu-id="397a7-322">Instead of creating `SqlCommand` and `SqlParameter` objects and then setting properties in separate statements, you can instead elect to use one of the overloaded constructors to set multiple properties in a single statement.</span></span>

[!code-csharp[DataWorks SqlClient.StoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.StoredProcedure/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.StoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.StoredProcedure/VB/source.vb#1)]

## <a name="using-parameters-with-an-oledbcommand-or-odbccommand"></a><span data-ttu-id="397a7-323">将参数与 OleDbCommand 或 OdbcCommand 一起使用</span><span class="sxs-lookup"><span data-stu-id="397a7-323">Using parameters with an OleDbCommand or OdbcCommand</span></span>

<span data-ttu-id="397a7-324">对 <xref:System.Data.OleDb.OleDbCommand> 或 <xref:System.Data.Odbc.OdbcCommand>使用参数时，添加到 `Parameters` 集合中的参数的顺序必须与在存储过程中定义的参数的顺序相匹配。</span><span class="sxs-lookup"><span data-stu-id="397a7-324">When using parameters with an <xref:System.Data.OleDb.OleDbCommand> or <xref:System.Data.Odbc.OdbcCommand>, the order of the parameters added to the `Parameters` collection must match the order of the parameters defined in your stored procedure.</span></span> <span data-ttu-id="397a7-325">用于 ODBC 的 OLE DB 和 .NET Framework 数据提供程序的 .NET Framework 数据提供程序将存储过程中的参数视为占位符并按顺序应用参数值。</span><span class="sxs-lookup"><span data-stu-id="397a7-325">The .NET Framework Data Provider for OLE DB and .NET Framework Data Provider for ODBC treat parameters in a stored procedure as placeholders and apply parameter values in order.</span></span> <span data-ttu-id="397a7-326">此外，返回值参数必须为添加到 `Parameters` 集合中的第一批参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-326">In addition, return value parameters must be the first parameters added to the `Parameters` collection.</span></span>

<span data-ttu-id="397a7-327">用于 ODBC 的 OLE DB 和 .NET Framework 数据提供程序的 .NET Framework 数据提供程序不支持将参数传递给 SQL 语句或存储过程的命名参数。</span><span class="sxs-lookup"><span data-stu-id="397a7-327">The .NET Framework Data Provider for OLE DB and .NET Framework Data Provider for ODBC do not support named parameters for passing parameters to an SQL statement or a stored procedure.</span></span> <span data-ttu-id="397a7-328">在此情况下，必须使用问号 (?) 占位符，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="397a7-328">In this case, you must use the question mark (?) placeholder, as in the following example.</span></span>

```sql
SELECT * FROM Customers WHERE CustomerID = ?
```

<span data-ttu-id="397a7-329">因此，将 `Parameter` 对象添加到 `Parameters` 集合的顺序必须直接与参数的问号 (?)</span><span class="sxs-lookup"><span data-stu-id="397a7-329">As a result, the order in which `Parameter` objects are added to the `Parameters` collection must directly correspond to the position of the ?</span></span> <span data-ttu-id="397a7-330">占位符的位置相对应。</span><span class="sxs-lookup"><span data-stu-id="397a7-330">placeholder for the parameter.</span></span>

### <a name="oledb-example"></a><span data-ttu-id="397a7-331">OleDb 示例</span><span class="sxs-lookup"><span data-stu-id="397a7-331">OleDb Example</span></span>

```vb
Dim command As OleDbCommand = New OleDbCommand( _
  "SampleProc", connection)
command.CommandType = CommandType.StoredProcedure

Dim parameter As OleDbParameter = command.Parameters.Add( _
  "RETURN_VALUE", OleDbType.Integer)
parameter.Direction = ParameterDirection.ReturnValue

parameter = command.Parameters.Add( _
  "@InputParm", OleDbType.VarChar, 12)
parameter.Value = "Sample Value"

parameter = command.Parameters.Add( _
  "@OutputParm", OleDbType.VarChar, 28)
parameter.Direction = ParameterDirection.Output
```

```csharp
OleDbCommand command = new OleDbCommand("SampleProc", connection);
command.CommandType = CommandType.StoredProcedure;

OleDbParameter parameter = command.Parameters.Add(
  "RETURN_VALUE", OleDbType.Integer);
parameter.Direction = ParameterDirection.ReturnValue;

parameter = command.Parameters.Add(
  "@InputParm", OleDbType.VarChar, 12);
parameter.Value = "Sample Value";

parameter = command.Parameters.Add(
  "@OutputParm", OleDbType.VarChar, 28);
parameter.Direction = ParameterDirection.Output;
```

## <a name="odbc-example"></a><span data-ttu-id="397a7-332">Odbc 示例</span><span class="sxs-lookup"><span data-stu-id="397a7-332">Odbc Example</span></span>

```vb
Dim command As OdbcCommand = New OdbcCommand( _
  "{ ? = CALL SampleProc(?, ?) }", connection)
command.CommandType = CommandType.StoredProcedure

Dim parameter As OdbcParameter = command.Parameters.Add("RETURN_VALUE", OdbcType.Int)
parameter.Direction = ParameterDirection.ReturnValue

parameter = command.Parameters.Add( _
  "@InputParm", OdbcType.VarChar, 12)
parameter.Value = "Sample Value"

parameter = command.Parameters.Add( _
  "@OutputParm", OdbcType.VarChar, 28)
parameter.Direction = ParameterDirection.Output
```

```csharp
OdbcCommand command = new OdbcCommand( _
  "{ ? = CALL SampleProc(?, ?) }", connection);
command.CommandType = CommandType.StoredProcedure;

OdbcParameter parameter = command.Parameters.Add( _
  "RETURN_VALUE", OdbcType.Int);
parameter.Direction = ParameterDirection.ReturnValue;

parameter = command.Parameters.Add( _
  "@InputParm", OdbcType.VarChar, 12);
parameter.Value = "Sample Value";

parameter = command.Parameters.Add( _
  "@OutputParm", OdbcType.VarChar, 28);
parameter.Direction = ParameterDirection.Output;
```

## <a name="see-also"></a><span data-ttu-id="397a7-333">另请参阅</span><span class="sxs-lookup"><span data-stu-id="397a7-333">See also</span></span>

- [<span data-ttu-id="397a7-334">命令和参数</span><span class="sxs-lookup"><span data-stu-id="397a7-334">Commands and Parameters</span></span>](commands-and-parameters.md)
- [<span data-ttu-id="397a7-335">DataAdapter 参数</span><span class="sxs-lookup"><span data-stu-id="397a7-335">DataAdapter Parameters</span></span>](dataadapter-parameters.md)
- [<span data-ttu-id="397a7-336">ADO.NET 中的数据类型映射</span><span class="sxs-lookup"><span data-stu-id="397a7-336">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="397a7-337">ADO.NET 概述</span><span class="sxs-lookup"><span data-stu-id="397a7-337">ADO.NET Overview</span></span>](ado-net-overview.md)
